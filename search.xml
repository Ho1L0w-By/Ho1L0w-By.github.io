<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《蛊真人》——小人物的坚持</title>
      <link href="/2022/06/17/guzhenren/"/>
      <url>/2022/06/17/guzhenren/</url>
      
        <content type="html"><![CDATA[<p>​在开始看这本小说的时候，我刚高二。但是我已经在网络小说的世界里经历了7年了。从小学的《斗罗大陆》，《斗破苍穹》，《冰火魔厨》……，到初中的《凡人修仙传》，《仙逆》，《无限恐怖》……</p><p>​到高中为止我已经看了很多网文，当然，也有很多的出版文学，每本书基本都能给我带来不同的感受，以及不同的思考，但是从未有一本书能够像《蛊真人》一样给我惊喜以及精神上的力量。</p><p>​《蛊真人》，作者也叫蛊真人。他用自己的奇思妙想为我们构建了一个千奇百怪的蛊的世界——“人是万物之灵，蛊是天地真精”。</p><p>​ 作者用各类蛊，将传统仙侠中讲究的所谓财侣法地合并在了一起，从而创造出了一个远远和我们认知中不同的蛊的世界。在传统的印象中，蛊是南疆巫毒的产物，是一种毒虫，用来害人的节肢类动物，有的还有一些奇妙的强身健体的效果。</p><p>​但是在蛊真人中，蛊远不止如此，它们有的长得像是昆虫，有的则像是器物，有的甚至什么都不是，就是单纯的一个概念，蛊千奇百怪。在传统仙侠中，用飞剑，那就有长得像是飞剑的飞剑蛊。在武侠中有金钟罩，那就有长成天牛的金钟罩蛊。修仙要想餐风饮露，那就有餐风蛊，饮露蛊，让你可以真的以风露为食，填饱肚子。你要治疗自己，那就有治疗蛊，你要快速移动，就有移动蛊。甚至你可以将蛊虫进行合炼，创造出新的蛊虫（例如有人用电蛊和爆脑蛊创造出了电脑蛊，用来开机甲）。除此之外，还有智慧蛊，力量蛊，希望蛊等等等等……</p><p>​作者用他的想象力为我们创建了一个丰富多彩的蛊虫的世界，里面的万事万物都离不开蛊，蛊就是财侣法地的表现化。但同时，作者也为这个世界赋予了与现实世界相似的残酷性。资源的竞争，人性的角逐，无处不在，人与人之间充满了算计，相互之间包藏祸心，因为这里是高武的世界，有人抛妻弃子，甚至杀死自己的父母，只为了获取更多的力量，为了让自己更加的强大，能够在世界中立足。从这个角度看，这充满奇幻色彩的蛊世界，却又和现实中的养蛊是那么的相似。将无数的毒虫放在一个瓮里，让他们自相残杀，而最后活下来的那一只，就是最毒，最凶猛的毒虫，也可以称为蛊。</p><p>​从这个角度来讲，主角古月方源，就是那一只最后练成的蛊。</p><p>​作者从一开始就讲过，他想写一个反派，一个真真正正的魔头，不会像是一般小说反派那般愚蠢，不会看见美女就走不动路，不会为了一点鸡毛蒜皮的矛盾就出言不逊等着主角打脸，而是永远有自己的理想，永远有自己的坚持，永远不会放弃，无论手段，无论方法，也要达成自己的目标。</p><p>​而这个魔头，就是古月方源。</p><p>​他残忍，他无情，他高大，他低贱，他辉煌，他平庸，他坏事做尽，坏事做绝。</p><p>​他可以为了一对骨肉相连蛊，毫不犹豫的害死一对双胞胎，他也可以为了提高自己的资质，让狗熊杀死一个少女。同样，他也可以为了让自己的听觉侦察范围更广，不用麻药切掉自己的一只耳朵，装上地听肉耳草蛊，用一把匕首生生的扒去自己全身人皮，以伪装成别人。他对别人狠，对自己更狠。</p><p>​《蛊真人》这本书的主要故事，就是跟着主角，古月方源开始他的永生大计。在这个世界用蛊的人被叫做蛊师，按照能力，可以分为一到九转，其中九转最强，被称为尊者，蛊尊。在这本书中，设定是蛊尊是绝对的无敌，只要出现了，九转之下，都是蝼蚁，但同时，每个大时代只能出现一位。</p><p>​方源的前世，从一介凡人不断修炼，历经千辛万苦，修炼到了六转蛊仙，他为元石发过愁，也赚过大钱，他当过乞丐，也做过商贾，他老过，他也用寿蛊恢复过年轻，他走过很远，穿过了山川与海洋。整个蛊世界，南疆，西漠，东海，北原和中州，五大域他都去过，漂泊三百年，修炼二百年，终于，成为了六转蛊仙，练就了一只奇蛊——春秋蝉。</p><p>​春秋蝉有穿越时空的能力，也因此，方源在被正道围攻，走到末路的时候，选择用自己的全身修为和性命为动力，催动春秋蝉回到过去。毫无疑问，春秋蝉是方源的金手指，虽然这个金手指有极大的副作用，成功率有限，如果失败，就是彻底自爆死亡，但仍然为方源提供了极大的助力。</p><p>​小说整体的故事，就是看穿越回五百年前的方源，是如何为了永生，开始谋划和冒险的。</p><p>​说到这里，是不是感觉这本书和别的后宫小说没什么区别？主角接下来无非就是打怪升级，靠着自己的前瞻性抢夺机缘，升级打脸，装X逆袭。但是这偏偏不是蛊真人的思路。</p><p>​你穿越回五百年前，优势很大？那就让未来因为你的蝴蝶效应而改变，让你只能获得部分的信息。你想要成仙？那就让你成仙之路断绝，变成仙僵，无法修炼，连思考能力都下降。你想要永生？那就让天意浩荡，所有人与你为敌，让你困难重重，让你命中注定不能永生。</p><p>​方源从南疆的青茅山走出来，到三王福地，八十八角真阳楼，义天山大战，再到天庭大战，他一步步走来，每一步都是刀光剑影，每一步都是荆棘险峻。你聪明，敌人和你一样聪明，你有信息差，敌人比你有更多的信息差，你有金手指，但是只能让你回到15分钟到一个小时之前，甚至还有可能失败。</p><p>​方源还剩什么？</p><p>​他到底要怎么取胜？</p><p>​其实，方源从来就没有什么作弊的金手指，或者说，他的金手指只有一个，不是春秋蝉，而是他的坚持。</p><p>​他坚持，所以他能够从青茅山走出来，成为甲等资质，他坚持，所以他不会接受命运的浮沉，他知道自己想要什么，他知道自己为了什么而坚持。</p><p>​就像是这本书的灵魂，《人祖传》里讲的一样</p><blockquote><p>人祖听了便问：“你们为什么要寻找自由蛊呢？”<br>　　鱼群们唉声叹气：“我们曾经拥有过自由蛊，但我们没有意识到。当我们失去了它，我们才发现自己没有了鱼鳃，再不能在水里呼吸。当我们重新获得自由，我们才可以在水里随意畅游。”<br>　　人祖大悟：“我明白了，人也得有自由。人如果没有了自由，就好像是鱼没有了腮，不能呼吸。”<br>　　“没错！”人祖一拍巴掌，大笑起来，“我要得到自由，摆脱宿命的束缚，我要自由自在的呼吸，永远存在下去，我要永生！”<br>　　鱼群纷纷冷笑：“人啊，你怎么能有这样的非分之想呢？”<br>　　“你瞧瞧我们，鱼鳃是鱼必须要有的，所以我们追寻自由是一种本分。”<br>　　“而你们人的一生注定和永生无缘，将会生老病死。人啊，你要追寻自由，也要恪守你的本分，可不能胡思乱想。”<br>　　人祖皱皱眉，神情厌烦：“是这样的吗？”<br>　　鱼群最后留下一句话：“人啊，让我们给你一个忠告吧。将来你若是得到了自由，千万要懂得珍惜，不要像我们一样轻易松手。千万不要放自由蛊飞走，不然你会后悔的。”<br>　　人祖和鱼群分别，渐渐的忘记了鸟群、豹群、鱼群关照他的话。<br>　　“我是人，我要追求自由！”</p></blockquote><p>也就像是方源打破宿命做的一样：</p><blockquote><p>人祖再说：他得到自由，摆脱宿命的束缚，要自由自在的呼吸，永远存在下去，他要永生不老！<br>　　鱼群否决他：你们人的一生注定和永生无缘，将会生老病死。人啊，你要追寻自由，也要恪守你的本分，可不能胡思乱想。<br>　　人祖疑惑。<br>　　人祖怏怏。<br>　　人祖厌烦。<br>　　人祖疯了！<br>　　你怎么可以这样想？<br>　　我为什么不能这样想？<br>　　一个人，为什么不能和爱人永不分离？<br>　　一个人，为什么不能衣食无忧，富贵滔天？<br>　　一个人，为什么不能永生不死不老？<br>　　就因为宿命不允许吗？<br>　　就因为它不允许，我就不能做！？我就不能想？！<br>　　凭什么？<br>　　他妈的凭什么？<br>　　凭什么不可以想！？<br>　　凭什么永生就不可行？！</p><p>​好吧。<br>　　如果这样想，让我疯。<br>　　那就让我成为疯子！<br>　　如果这样追寻，让我魔。<br>　　那就让我成为魔头！！<br>　　方源望着手中的宿命蛊，冷冷一笑。<br>　　他手轻轻一用力。<br>　　咯嘣。<br>　　一声轻响。<br>　　宿命蛊被他直接捏成碎片。<br>　　九转宿命蛊——<br>　　毁了！</p></blockquote><p>我看过四本讲勇气和坚持的书。</p><p>《老人与海》看时懵懵懂懂，后来我看到了老人面对残酷生活的乐观，他只有勇气，但是却少了坚持。</p><p>《钢铁是怎样炼成的》保尔柯察金的勇气和坚持让我怜悯，我说，我如果像他一样不幸，我应该会放弃。</p><p>《钢之炼金术士》艾尔利克兄弟的友谊和三观，以及钢铁般的勇气和坚持让我感动，我说，如果我向他们一样不幸，我也要学会爱人，学会坚持。</p><p>而《蛊真人》，方源的坚持让我感到震撼。</p><blockquote><p>​他面无表情，不管走多少步，逆流河永远流淌在他的脚下，仿佛是绝大的命运的嘲笑。<br>　　但是他仍旧走着。<br>　　他从前世五百年走来，不知要走到什么时候<br>但他知道，自己要去往何方。<br>　　似乎……没有人能阻止他。<br>　　至少……如今的逆流中，已经无人可阻。<br>　　前世五百年前。<br>　　方源倚在竹楼上，看看山寨，又仰望背后的青茅山。<br>　　双手握拳，稚嫩的小脸上，满是希冀。<br>　　“是时候放弃过去了。”<br>　　“穿越到这里来，这是我的福缘！因为在这里，可以实现长生。”<br>　　“我要把握这样难得的机会！不然，怎么对得起自己，对得起这份机缘？”<br>　　“当然，目前阶段，是提升我和弟弟的生活环境。嘿，那个小家伙……”<br>　　开窍之后。<br>　　演武场上，方源垂下头，一脸惊怒。<br>　　“被暗算了！”<br>　　“是谁暗算我？不愿意让我战胜对手？答案不言而喻！”<br>　　“哥哥，放弃吧，你不会是我的对手。因为天资不同，我们注定不同。”眼前的古月方正带着快意道。<br>　　方源转头就走，他的眼中全是坚定之色。<br>　　“既然山寨不栽培我，舅父舅母甚至都故意排挤我，我留在这里有什么意思？”<br>“难道在这里就可以变强，实现长生么？”<br>　　“不如出去？”<br>　　商队里。<br>　　大胡子蛊师死了，方源站在他的墓前。<br>　　少年满含泪水，哽咽地道：“胡子大叔，你安息吧。”<br>　　“谢谢你临走前的礼物。”<br>　　“你说：小时候，你想成为顶天立地的人物，就像是正道的那些传奇人物那样。少年时，觉得成为一族族长也不错。青年时，能够成为家老就感觉很棒了。中年后，被家族流放，发现其实能养得活自己，养得起身上的蛊虫，就能让自己满意。”<br>　　“我不会这样，让梦想随着年龄而萎缩。”<br>　　“这个世界太大，而我们都是小人物……但我会加油的！会一直努力！”<br>　　……<br>　　童年、少年、青年。<br>　　青茅山、商队，一路行走。<br>　　壮年、老年，终究获得寿蛊。<br>　　南疆、西漠、东海、中洲。<br>　　春秋蝉重生后，青茅山、三王山、狐仙福地、王庭福地、义天山、逆流河！<br>　　一步步走来，一路风雨。<br>　　碧晨天皱起眉头，他盯着方源的身影，心中<br>呢喃道：“这是何等的意志！他究竟为什么坚持？是什么能让他如此坚持？”<br>　　雪胡老祖冷哼，眼中闪过郑重之色，再无之前面对一般七转蛊仙的轻蔑：“这么说来，三十万年前有元莲，三十万后有柳贯一……逆流河主啊。”<br>　　毛里球望着方源身上越盛的光辉，无可奈何，龇牙咧嘴，爪子下意识地在地面上挠，挠出道道深痕。<br>　　白凝冰、黑楼兰俱都眼角狂跳，神情动容。<br>　　赵怜云此刻悠悠醒转，她望着方源另一个胳膊下夹着的，马鸿运的尸体，她的眼泪夺眶而出。<br>　　她在心中哭嚎：“鸿运，鸿运，你怎么可以离我而去。没有了你，我在这个世界上，就是孤家寡人。我活着还有什么意思？你知道吗？一个人的坚持是有多难！”<br>　　一个人的坚持会有多难？<br>　　在场的所有蛊仙，都能回答这个问题。<br>　　因为他们当中，有的因为责任而坚持，有的因为仇恨而坚持，有的因为精彩而坚持，有的因为爱情而坚持……<br>　　而方源的回答呢？<br>　　他仍旧面无表情，毫无所动地向前进。<br>　　我曾经呐喊过，渐渐的我不发出声音。<br>　　我曾经哭泣过，渐渐的我不再流泪。</p><p>​我曾经悲伤过，渐渐的我能承受一切。<br>　　我曾经喜悦过，渐渐的我看淡世间。<br>　　而如今！<br>　　我只剩下面无表情，我的目光如磐石般坚硬，我的心中剩下坚持。<br>　　这就是我，一个小人物，方源的——坚持！</p></blockquote><p>有人说，真正的英雄主义，是认清了生活的残酷，仍然能热爱生活。那方源应当是当之无愧的英雄。他残忍，他无情，他低贱，他卑微，他坚强，他冷静，他高大，他辉煌，他坚持，他是古月方源。</p><p>在高考前，方源的精神无数次的鼓励了我，安慰了我孤独的心。每每看见方源的坚持，就又能让我拥有力量，去面对生活中的一切苦难，同时保持自己的本心。</p><p>我曾经呐喊过，渐渐的我不发出声音。<br>我曾经哭泣过，渐渐的我不再流泪。<br>我曾经悲伤过，渐渐的我能承受一切。<br>我曾经喜悦过，渐渐的我看淡世间。</p><p>我是真人，我是古月方源。</p><p>如果满分是十分，这本书我会毫不犹豫的给他9.8分，这是超出了网络小说的一本书，是能给人以力量的精神食量，虽然需要辩证看待，但是，他给人的力量是实打实的。</p><p>坚持，方源的坚持。</p>]]></content>
      
      
      <categories>
          
          <category> 书评 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 写作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,World!</title>
      <link href="/2022/06/15/hello/"/>
      <url>/2022/06/15/hello/</url>
      
        <content type="html"><![CDATA[<p>很高兴，终于把博客搭建好了。</p><p>之前为了搭建这个玩意我来来回回折腾了好久。最开始是使用的NEXT主题，结果遇到了一堆问题。而且node.js也在疯狂的爆出各种错误。然后github也没办法使用hexo d去进行文章推送。</p><p>从一开始到现在，差不多算是折腾了一个星期吧（省去中间的相隔的时间）</p><p>啥时候有时间我再写一篇博客搭建记录。</p><p>不过现在嘛，还是只能说很高兴吧，最开始的时候一直是使用CSDN博客进行凑数的。</p><p>经过了一年的学习，对于信息安全也越发的热爱了，终于想起来要搭建一个个人博客。</p><p>那句话怎么说的来着？生活要有仪式感？</p><p>哈。</p><p>这个就算是我的仪式感吧。</p><p>以后我会尽量把我自己的学习记录到博客上，然后对于我自己看一些东西，我也会自己写一些书评，基本还是给自己一个记录吧。</p><p>可能还会给自己写一些日记之类的，到时候加一个加密功能。</p><p>嗯，差不多就记录到这里。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF(服务器端请求伪造)漏洞</title>
      <link href="/2022/06/15/SSRF(%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)%E6%BC%8F%E6%B4%9E%EF%BC%9A/"/>
      <url>/2022/06/15/SSRF(%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)%E6%BC%8F%E6%B4%9E%EF%BC%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="SSRF-服务器端请求伪造-漏洞-理论部分-："><a href="#SSRF-服务器端请求伪造-漏洞-理论部分-：" class="headerlink" title="SSRF(服务器端请求伪造)漏洞(理论部分)："></a>SSRF(服务器端请求伪造)漏洞(理论部分)：</h1><h2 id="1、概述："><a href="#1、概述：" class="headerlink" title="1、概述："></a>1、概述：</h2><p><strong>SSRF(Server-Side Request Forgery:服务器端请求伪造)</strong></p><p>是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。</p><p>一般情况下，SSRF攻击的目标是从外网无法访问的<strong>内部系统</strong>。（因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内网。也就是说可以利用一个网络请求的服务，当作跳板进行攻击）</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/20200226013932770.png" alt="在这里插入图片描述"></p><blockquote><p>SSRF和CSRF（Cross-site request forgery）其实是有点相关的，挺有意思，一个是服务器请求伪造，一个是跨站请求伪造。</p></blockquote><h2 id="2、漏洞成因："><a href="#2、漏洞成因：" class="headerlink" title="2、漏洞成因："></a>2、漏洞成因：</h2><p>SSRF 形成的原因往往是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p><p>如：从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。利用的就是服务端的请求伪造。ssrf是利用<strong>存在缺陷的web应用作为代理</strong>攻击远程和本地的服务器。</p><p>（举个例子，博客里的图片引用一般都是通过url的方式来进行引用的，这其实就是请求了别的服务器上存储的图片数据，如果没有对这个数据进行过滤的话，可能就会被造成SSRF攻击）</p><h2 id="3、常见漏洞点："><a href="#3、常见漏洞点：" class="headerlink" title="3、常见漏洞点："></a>3、常见漏洞点：</h2><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220622165334021.png" alt="image-20220622165334021"></p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220622165343882.png" alt="image-20220622165343882"></p><p>博客里面用来读取图片的这一段也算。</p><h2 id="4、实现攻击方式："><a href="#4、实现攻击方式：" class="headerlink" title="4、实现攻击方式："></a>4、实现攻击方式：</h2><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的<a href="http://www.cnblogs.com/yuanshu/p/11588341.html">banner 信息</a></li><li>攻击运行在内网或本地的应用程序</li><li>对内网 WEB 应用进行指纹识别，通过访问默认文件实现(如：readme文件)</li><li>攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击(如：Struts2，sqli)</li><li>下载内网资源(如：利用<code>file</code>协议读取本地文件等)</li><li>进行跳板</li><li>无视cdn</li><li>利用Redis未授权访问，HTTP CRLF注入实现getshell</li></ol><h2 id="5、SSRF漏洞相关函数和协议："><a href="#5、SSRF漏洞相关函数和协议：" class="headerlink" title="5、SSRF漏洞相关函数和协议："></a>5、SSRF漏洞相关函数和协议：</h2><h3 id="1、file-get-contents"><a href="#1、file-get-contents" class="headerlink" title="1、file_get_contents()"></a>1、file_get_contents()</h3><p>函数作用：</p><blockquote><p>将整个文件读入道一个字符串中：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220622170026752.png" alt="image-20220622170026752"></p></blockquote><p><strong>（注意，不只是可以用来读取本地文件，同样也可以用来访问url表示的外部文件，否则就不会出现SSRF了）</strong></p><p><code>file_get_content</code>函数从用户指定的url获取内容，然后指定一个文件名进行保存，并展示给用户。file_put_content函数把一个字符串写入文件中。</p><p><strong>需要将php.ini中的allow_url_fopen设为on状态。</strong>预设是启动的。</p><p>eg:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、fsockopen"><a href="#2、fsockopen" class="headerlink" title="2、fsockopen()"></a>2、fsockopen()</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220622171221093.png" alt="image-20220622171221093"></p></blockquote><p>使用例：</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220622171258168.png" alt="image-20220622171258168"></p></blockquote><p>这个函数的作用就是实现用户对于指定url数据的获取，使用套接字与服务器建立<code>tcp</code>连接，传输数据，变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30是时限。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFile</span>(<span class="params"><span class="variable">$host</span>,<span class="variable">$port</span>,<span class="variable">$link</span></span>) </span>&#123; </span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="title function_ invoke__">intval</span>(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);   </span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (error number <span class="subst">$errno</span>) \n&quot;</span>;  <span class="comment">//errno应该是错误号，404这种</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="variable">$out</span> = <span class="string">&quot;GET <span class="subst">$link</span> HTTP/1.1\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;\r\n&quot;</span>; </span><br><span class="line">        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>); </span><br><span class="line">        <span class="variable">$contents</span>=<span class="string">&#x27;&#x27;</span>; </span><br><span class="line">        <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) &#123; </span><br><span class="line">            <span class="variable">$contents</span>.= <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">1024</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$contents</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以和Python中的socket模块里的，socket.socket函数类比一下。用于建立传输链接。</p><h3 id="3、curl-exec"><a href="#3、curl-exec" class="headerlink" title="3、curl_exec()"></a>3、curl_exec()</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220623141239861.png" alt="image-20220623141239861"></p></blockquote><p>函数用于执行指定的curl会话。</p><blockquote><p>**什么是cURL?**（<a href="https://baike.baidu.com/item/curl/10098606?fr=aladdin%EF%BC%89">https://baike.baidu.com/item/curl/10098606?fr=aladdin）</a></p><p><strong>cURL是一个利用URL语法在命令行下工作的文件传输工具</strong>，1997年首次发行。</p><p>cURL支持的通信协议有：</p><p><a href="https://baike.baidu.com/item/FTP">FTP</a>、<a href="https://baike.baidu.com/item/FTPS">FTPS</a>、<a href="https://baike.baidu.com/item/HTTP">HTTP</a>、<a href="https://baike.baidu.com/item/HTTPS">HTTPS</a>、<a href="https://baike.baidu.com/item/TFTP">TFTP</a>、<a href="https://baike.baidu.com/item/SFTP">SFTP</a>、<a href="https://baike.baidu.com/item/Gopher">Gopher</a>、<a href="https://baike.baidu.com/item/SCP">SCP</a>、<a href="https://baike.baidu.com/item/Telnet">Telnet</a>、DICT、FILE、<a href="https://baike.baidu.com/item/LDAP">LDAP</a>、LDAPS、<a href="https://baike.baidu.com/item/IMAP">IMAP</a>、<a href="https://baike.baidu.com/item/POP3">POP3</a>、<a href="https://baike.baidu.com/item/SMTP">SMTP</a>和<a href="https://baike.baidu.com/item/RTSP">RTSP</a>。</p><p>此外，cURL还支持SSL认证，HTTP POST、HTTP PUT、FTP上传, HTTP form based upload、proxies、HTTP&#x2F;2、cookies、用户名+密码认证（包含了多种加密方式。）</p><p>常见的使用方法：</p><p><strong>获得页面</strong></p><p>使用命令：curl <a href="http://curl.haxx.se/">http://curl.haxx.se</a></p><p>这是最简单的使用方法。用这个命令获得了<a href="http://curl.haxx.se指向的页面,同样,如果这里的url指向的是一个文件或者一幅图都可以直接下载到本地.如果下载的是html文档,那么缺省的将只显示文件头部,即html文档的header.要全部显示,请加参数/">http://curl.haxx.se指向的页面，同样，如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。如果下载的是HTML文档，那么缺省的将只显示文件头部，即HTML文档的header。要全部显示，请加参数</a> -i，要只显示头部，用参数 -I。任何时候，可以使用 -v 命令看curl是怎样工作的，它向服务器发送的所有命令都会显示出来。为了<a href="https://baike.baidu.com/item/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0">断点续传</a>，可以使用-r参数来指定传输范围。 </p><p><strong>获取表单</strong></p><p>可以使用各种不同的参数来进行表单的传值，可以使用POST，也可以使用GET，同时也可以使用PUT或者是别的方式进行提交。</p><p><strong>有关认证</strong></p><p>可以处理各种情况的认证界面，例如提交用户名和密码。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -U proxyuser:proxypassword http://curl.haxx. se</span><br></pre></td></tr></table></figure><p><strong>引用</strong></p><p>有的网络资源访问的时候必须经过另外一个网络地址跳转过去，也就是使用了referer（可以参考一下http请求中的）</p><p><strong>指定客户端</strong></p><p>有的网络资源首先需要判断用户使用的是什么浏览器，符合了标准才能够下载或者浏览，可以使用curl伪装成为需要的浏览器。</p><p><strong>Cookie</strong></p><p>Cookie是服务器经常使用的一种记忆客户信息的方法，如果cookie被记录在了文件中，则可以根据旧的cookie写出性的，发送到网站。</p><p><strong>加密HTTP</strong></p><p>可以直接通过cURL访问网站。</p><p><strong>http认证</strong></p><p>如果是采用证书认证的http地址，证书在本地，则可以使用本地的证书认证来进行访问。</p><p>PHP中相关函数在4.0.2版本后被引入，相关函数：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220624145606239.png" alt="image-20220624145606239"></p></blockquote><p><strong>注意：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.一般情况下PHP不会开启fopen的gopher wrapper</span><br><span class="line">2.file_get_contents的gopher协议不能URL编码</span><br><span class="line">3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败</span><br><span class="line">4.curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用</span><br><span class="line">5.curl_exec() //默认不跟踪跳转，</span><br><span class="line">6.file_get_contents() // file_get_contents支持php://input协议</span><br></pre></td></tr></table></figure><h3 id="4、fopen"><a href="#4、fopen" class="headerlink" title="4、fopen()"></a>4、fopen()</h3><p>用于打开一个文件或者是一个url。</p><h3 id="5、readfile"><a href="#5、readfile" class="headerlink" title="5、readfile()"></a>5、readfile()</h3><p>输出一个文件的内容。</p><h3 id="相关协议："><a href="#相关协议：" class="headerlink" title="相关协议："></a>相关协议：</h3><p>（1）<code>file</code>： 在有回显的情况下，利用 file 协议可以读取任意内容<br>（2）<code>dict</code>：泄露安装软件版本信息，查看端口，操作内网redis服务等<br>（3）<code>gopher</code>：gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell<br>（4）<code>http/s</code>：探测内网主机存活</p><p>（5）<code>FastCGI</code>：FastCGI协议</p><p>（6）<code>Redis</code>：REPS协议</p><p><strong>协议说明：</strong></p><h4 id="Gopher协议："><a href="#Gopher协议：" class="headerlink" title="Gopher协议："></a>Gopher协议：</h4><blockquote><p>Gopher协议是Internet上一个非常有名的信息查找系统，他将Internet上的文件组织成某种索引，很方便的将用户从Internet的一处带到另一处。在WWW出现之前，GOpher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但是在WWW出现之后，Gopher失去了昔日的辉煌。现在它基本果实，人们很少使用它。</p></blockquote><p>Gopher协议支持发送GET，POST请求，可以先结果GET请求包，和POST请求包，再构成复合Gopher协议的请求。</p><p>**gopher会将后面的数据部分发送给相应的端口，这些数据可以是字符串，也可以是其他的数据请求包，比如GET，POST请求，redis，mysql未授权访问等，同时数据部分必须要进行url编码，这样gopher协议才能正确解析。<br>支持gopher协议的有  和  **</p><p><strong>Gopher协议格式</strong>：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">URL:gopher:<span class="comment">//&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span></span><br></pre></td></tr></table></figure><p><strong>默认使用端口：</strong>70</p><p>如果发起POST请求，需要使用<code>%0d%0a</code>作为换行符，如果多个参数，需要将链接符号<code>&amp;</code>也进行URL编码。</p><p>可以用于攻击内网的Redis，Mysql，FastCGI，FTP等，也可以发送GET，POST请求，拓宽了SSRF的攻击面。</p><p>（例如可以使用file协议，进行本地文件读取）</p><h4 id="FastCGI协议："><a href="#FastCGI协议：" class="headerlink" title="FastCGI协议："></a>FastCGI协议：</h4><blockquote><p>早期的Web服务器，只能响应浏览器发来的HTTP静态资源的请求，并将存储在服务器中的静态资源返回给浏览器。随着Web技术的发展，逐渐出现了动态技术，但是Web服务器并不能够直接运行动态脚本，为了解决Web服务器与外部应用程序(CGI程序)之间数据胡同，于是出现了CGI(Common Gateway Interface)通用网关接口。<strong>简单理解，可以认为CGI是Web服务器和运行在其上的应用程序进行“交流”的一种约定。</strong></p><p>当遇到动态脚本请求的时候，Web服务器的主进程就会Fork创建出一个新的进程来启动CGI程序，运行C、PHP等脚本程序的时候，也就是将动态脚本交给CGI程序进行处理。</p><p><strong>启动CGI程序需要一个过程，如读取配置文件、加载扩展等。当CGI程序启动后会去解析动态脚本，然后将结果返回给Web服务器，最后由Web服务器将结果返回给客户端，之前Fork出来的进程也随之关闭。</strong>这样，每次用户请求动态脚本，Web服务器都要重新Fork创建一个新进程去启动CGI程序，由CGI程序来处理动态脚本，处理完成后进程随之关闭，其效率是非常低下的。</p><p>而对于Mod CGI，Web服务器可以内置Perl解释器或PHP解释器。也就是说将这些解释器做成模块的方式，Web服务器会在启动的时候就启动这些解释器。当有新的动态请求进来时，Web服务器就是自己解析这些动态脚本，省得重新Fork一个进程，效率提高了。</p></blockquote><blockquote><p>使用CGI可以解决Web服务器与PHP解释器的通信问题，但是Web服务器有一个问题，来回启动CGI程序然后再杀掉，是非常浪费资源的，于是出现了优化版本，FastCGI(Fast Common Gateway Interface)快速通用网关接口。</p><p><strong>Fast-CGI每次处理完请求后，不会kill掉这个进程，而是保留这个进程，从而使服务器可以同时处理更多的网页请求。这样就会大大的提高效率。</strong></p></blockquote><p><strong>动态网页访问：</strong></p><p>当访问动态网站的主页时，根据容器的配置文件，它知道这个页面不是静态页面，Web容器就会去找PHP解析器来进行处理（这里以Apache为例），它会把这个请求进行简单的处理，然后交给PHP解释器。</p><p>当Apache收到用户对 index.php 的请求后，如果使用的是CGI，会启动对应的 CGI  程序，对应在这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以CGI规定的格式返回处理后的结果，退出进程，Web Server 再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程。</p><p>这里说的是使用CGI，而FastCGI就相当于高性能的CGI，与CGI不同的是它像一个常驻的CGI，在启动后会一直运行着，不需要每次处理数据时都启动一次， 所以这里引出下面这句概念，FastCGI是语言无关的、可伸缩架构的CGI开放扩展，<strong>其主要行为是将CGI解释器进程保持在内存中</strong>，并因此获得较高的性能 。</p><p><strong>协议分析：</strong></p><p>FastCGI其实是一个通信协议，和HTTP协议一样，都是进行数据交换的一个通道。</p><p>HTTP协议是 <strong>浏览器和服务器中间件</strong> 进行数据交换的协议，浏览器将HTTP头和HTTP体用某个规则组装成数据包，以TCP的方式发送到服务器中间件，服务器中间件按照规则将数据包解码，并按要求拿到用户需要的数据，再以HTTP协议的规则打包返回给服务器。</p><p>类比 HTTP 协议来说，<code>FastCGI</code>协议则是 <strong>服务器中间件和某个语言后端</strong>  进行数据交换的协议，同时直接使用二进制传递数据。Fastcgi 协议由多个 <code>Record</code> 组成，Record 也有 Header 和 Body  一说，服务器中间件将这二者按照 Fastcgi 的规则封装好发送给语言后端，语言后端解码以后拿到具体数据，进行指定操作，并将结果再按照  Fastcgi 协议封装好后返回给<strong>服务器中间件</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220624193417656.png" alt="image-20220624193417656"></p><h5 id="FastCGI-Record的格式："><a href="#FastCGI-Record的格式：" class="headerlink" title="FastCGI Record的格式："></a><strong>FastCGI Record的格式：</strong></h5><p><strong>头部，身体：</strong></p><p>Record的头固定8个字节，body的大小由头部中contentLenght指定（两字节），结构如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  <span class="comment">/* Header */</span></span><br><span class="line">  unsigned char version; <span class="comment">// 版本</span></span><br><span class="line">  unsigned char type; <span class="comment">// 本次record的类型</span></span><br><span class="line">  unsigned char requestIdB1; <span class="comment">// 本次record对应的请求id(一个变量是一个字节，这里是两个变量，所以一共两个字节)</span></span><br><span class="line">  unsigned char requestIdB0; <span class="comment">//变量2</span></span><br><span class="line">  unsigned char contentLengthB1; <span class="comment">// body体的大小（同上，两个变量，一共两个字节）</span></span><br><span class="line">  unsigned char contentLengthB0;</span><br><span class="line">  unsigned char paddingLength; <span class="comment">// 额外块大小</span></span><br><span class="line">  unsigned char reserved;     <span class="comment">//保留字段</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Body */</span></span><br><span class="line">  unsigned char contentData[contentLength];     <span class="comment">//body内容数据</span></span><br><span class="line">  unsigned char paddingData[paddingLength];     <span class="comment">//填充数据</span></span><br><span class="line">&#125; FCGI_Record;</span><br></pre></td></tr></table></figure><p>头由8个 uchar 类型的变量组成，每个变量一个字节。其中，<code>requestId</code> 占两个字节，一个唯一的标志id，以避免多个请求之间的影响；<code>contentLength</code> 占两个字节，表示 Body 的大小。可见，一个 Fastcgi Record 结构最大支持的 Body 大小是<code>2^16</code>，也就是 65536 字节（两个字节十六位，一位表示1，0两种情况）。</p><p><strong>字段选项：</strong></p><p>刚才我们介绍了 Fastcgi 协议中Record部分中各个结构的含义，其中第二个字节为 <code>type</code>，我们将对其进行详细讲解。</p><p><code>type</code> 就是指定该 Record 的作用。因为 Fastcgi 中一个 Record 的大小是有限的，作用也是单一的，所以我们需要在一个TCP流里传输多个 Record，通过 <code>type</code> 来标志每个 Record 的作用，并用 <code>requestId</code> 来标识同一次请求的id。也就是说，每次请求，会有多个 Record，他们的 <code>requestId</code> 是相同的。</p><p>type字段选项：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FCGI_Type</span> </span>&#123;</span><br><span class="line">  FCGI_BEGIN_REQUEST     = <span class="number">1</span>,  <span class="comment">// (WEB-&gt;FastCGI) 表示一次请求的开始</span></span><br><span class="line">  FCGI_ABORT_REQUEST     = <span class="number">2</span>,  <span class="comment">// (WEB-&gt;FastCGI) 表示终止一次请求</span></span><br><span class="line">  FCGI_END_REQUEST       = <span class="number">3</span>,  <span class="comment">// (FastCGI-&gt;WEB) 请求已被处理完毕</span></span><br><span class="line">  FCGI_PARAMS            = <span class="number">4</span>,  <span class="comment">// (WEB-&gt;FastCGI) 表示一个向CGI程序传递的环境变量</span></span><br><span class="line">  FCGI_STDIN             = <span class="number">5</span>,  <span class="comment">// (WEB-&gt;FastCGI) 表示向CGI程序传递的标准输入</span></span><br><span class="line">  FCGI_STDOUT            = <span class="number">6</span>,  <span class="comment">// (FastCGI-&gt;WEB) 表示CGI程序的标准输出   </span></span><br><span class="line">  FCGI_STDERR            = <span class="number">7</span>,  <span class="comment">// (FastCGI-&gt;WEB) 表示CGI程序的标准错误输出</span></span><br><span class="line">  FCGI_DATA              = <span class="number">8</span>,  <span class="comment">// (WEB-&gt;FastCGI) 向CGI程序传递的额外数据</span></span><br><span class="line">  FCGI_GET_VALUES        = <span class="number">9</span>,  <span class="comment">// (WEB-&gt;FastCGI) 向FastCGI程序询问一些环境变量</span></span><br><span class="line">  FCGI_GET_VALUES_RESULT = <span class="number">10</span>, <span class="comment">// (FastCGI-&gt;WEB) 询问环境变量的结果</span></span><br><span class="line">  FCGI_UNKNOWN_TYPE      = <span class="number">11</span>  <span class="comment">// 未知类型，可能用作拓展</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220624194357920.png" alt="image-20220624194357920"></p><p>看了这个表格就很清楚了，服务器中间件和后端语言通信，第一个数据包就是 <code>type</code> 为1的 Record，后续互相交流，发送 <code>type</code> 为4、5、6、7的 Record，结束时发送 <code>type</code> 为2、3的 Record。</p><p>当后端语言接收到一个 <code>type</code> 为4的 Record 后，就会把这个 Record 的 Body 按照对应的结构解析成 key-value 对，这就是环境变量。环境变量的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB0;  /* nameLengthB0  &gt;&gt; 7 == 0 */</span><br><span class="line">  unsigned char valueLengthB0; /* valueLengthB0 &gt;&gt; 7 == 0 */</span><br><span class="line">  unsigned char nameData[nameLength];</span><br><span class="line">  unsigned char valueData[valueLength];</span><br><span class="line">&#125; FCGI_NameValuePair11;</span><br><span class="line"> </span><br><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB0;  /* nameLengthB0  &gt;&gt; 7 == 0 */</span><br><span class="line">  unsigned char valueLengthB3; /* valueLengthB3 &gt;&gt; 7 == 1 */</span><br><span class="line">  unsigned char valueLengthB2;</span><br><span class="line">  unsigned char valueLengthB1;</span><br><span class="line">  unsigned char valueLengthB0;</span><br><span class="line">  unsigned char nameData[nameLength];</span><br><span class="line">  unsigned char valueData[valueLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">&#125; FCGI_NameValuePair14;</span><br><span class="line"> </span><br><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB3;  /* nameLengthB3  &gt;&gt; 7 == 1 */</span><br><span class="line">  unsigned char nameLengthB2;</span><br><span class="line">  unsigned char nameLengthB1;</span><br><span class="line">  unsigned char nameLengthB0;</span><br><span class="line">  unsigned char valueLengthB0; /* valueLengthB0 &gt;&gt; 7 == 0 */</span><br><span class="line">  unsigned char nameData[nameLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">  unsigned char valueData[valueLength];</span><br><span class="line">&#125; FCGI_NameValuePair41;</span><br><span class="line"> </span><br><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB3;  /* nameLengthB3  &gt;&gt; 7 == 1 */</span><br><span class="line">  unsigned char nameLengthB2;</span><br><span class="line">  unsigned char nameLengthB1;</span><br><span class="line">  unsigned char nameLengthB0;</span><br><span class="line">  unsigned char valueLengthB3; /* valueLengthB3 &gt;&gt; 7 == 1 */</span><br><span class="line">  unsigned char valueLengthB2;</span><br><span class="line">  unsigned char valueLengthB1;</span><br><span class="line">  unsigned char valueLengthB0;</span><br><span class="line">  unsigned char nameData[nameLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">  unsigned char valueData[valueLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">&#125; FCGI_NameValuePair44;</span><br></pre></td></tr></table></figure><p>这其实是4个结构，至于用哪个结构，有如下规则：</p><p>1、key、value均小于128字节，用FCGI_NameValuePair11</p><p>2、key大于128字节，value小于128字节，用FCGI_NameValuePair41</p><p>3、key小于128字节，value大于128字节，用FCGI_NameValuePair14</p><p>4、key、value均大于128字节，用FCGI_NameValuePair44</p><h5 id="PHP-FPM："><a href="#PHP-FPM：" class="headerlink" title="PHP-FPM："></a>PHP-FPM：</h5><p>官方对PHP-FPM的解释是 FastCGI 进程管理器，用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。PHP-FPM 默认监听的端口是 9000 端口。</p><p>也就是说 <strong>PHP-FPM 是 FastCGI 的一个具体实现</strong>，并且提供了进程管理的功能，在其中的进程中，包含了 master 和 worker 进程，这个在后面我们进行环境搭建的时候可以通过命令查看。其中<strong>master 进程负责与 Web 服务器中间件进行通信</strong>，接收服务器中间按照 FastCGI 的规则打包好的用户请求，再将请求转发给 worker 进程进行处理。<strong>worker 进程主要负责后端动态执行 PHP 代码，</strong>处理完成后，将处理结果返回给 Web 服务器，再由 Web 服务器将结果发送给客户端。</p><blockquote><p>简单来说，这个就是一个基于PHP语言实现的FastCGI进程管理器，因为FastCGI只是一个协议规范，需要每个语言具体去实现，PHP-FPM就是PHP版本的FastCGI协议的具体实现。使用这个，就是实现PHP脚本与Web服务器之间的同行，同时也是一个PHP SAPI，从而构建起了PHP解释器与Web服务器之间的桥梁。（或者可以理解为是PHP的环境，同时也是传输数据用的）</p></blockquote><p>例如当用户对<code>http://127.0.0.1/index.php?a=1&amp;b=2</code>进行访问的时候，根据Web服务器的目录，Web服务器的中间件，将相关的请求进行变换，修改为key-value对（键值对）</p><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;, &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/index.php&#x27;, &#x27;SCRIPT_NAME&#x27;: &#x27;/index.php&#x27;, &#x27;QUERY_STRING&#x27;: &#x27;?a=1&amp;b=2&#x27;, &#x27;REQUEST_URI&#x27;: &#x27;/index.php?a=1&amp;b=2&#x27;, &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;, &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: &#x27;12345&#x27;, &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;, &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;&#125;</span><br></pre></td></tr></table></figure><p>总的来说，将具体请求更改为键值对，进行传输，可以看见，其中包含了网关，请求方式，Web服务器根目录，还有服务器名字等具体信息。</p><p>这个数组其实就是PHP中的预定义数组，__SERVER的一部分，也就是相当于是PHP中的环境变量，既可以对__SERVER数组进行填充，同时也可以对FPM（环境）告知需要执行的PHP文件。</p><p>当PHP-FPM拿到FastCGI的数据包的时候，进行解析，得到上述的环境变量，然后执行<code>SCRIPT_FILENAME</code>的值指向的PHP文件</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220702113123515.png" alt="image-20220702113123515"></p><p>（在这个部分）</p><p>如果可以进行更改，那就可以实现未授权访问。</p><h6 id="PHP-FPM任意代码执行"><a href="#PHP-FPM任意代码执行" class="headerlink" title="PHP-FPM任意代码执行:"></a>PHP-FPM任意代码执行:</h6><p>Web服务器中间件，会将用户请求设置为环境变量，并且会通过字段<code>SCRIPT_FILENAME</code>来对中间件执行的PHP文件进行设置。</p><p>理论上是只能对已经存在的文件进行执行，而不能进行任意代码执行。</p><p>但是因为在PHP 5.3.9以上的版本中，PHP多了一个选项<code>security.limit_extensions</code>安全选项。</p><p>导致PHP-FPM可以进行控制执行的文件只有php,php3,php4,php5,php7这样的文件。</p><p><strong>但是可以利用PHP中存在的配置：</strong></p><p><code>auto_prepend_file</code>:在执行目标文件之前先对auto_prepend_file中指定的文件进行包含。</p><p><code>auto_append_file</code>:在执行了目标文件之后，对auto_append_file指定的文件进行包含。</p><blockquote><p>也就是说，将<code>auto_prepend_file</code>选项设为<code>php://input</code>(将POST中的内容作为PHP代码执行)，那么在执行任何PHP文件之前都要对POST的内容进行一次文件执行。</p><p>也就是，将HTTP请求的body部分进行改写，就能够执行了。</p></blockquote><p>不过使用php:&#x2F;&#x2F;input使用也需要启用相关的配置。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220702120556587.png" alt="image-20220702120556587"></p><p><strong>如何设置环境变量的值：</strong></p><p>对于auto_prepend_file这类的环境变量，我们要想设置成php:&#x2F;&#x2F;input，就需要远程设置。</p><p>在PHP-FPM中有两个环境变量，<code>PHP_VALUE</code>和<code>PHP_ADMIN_VALUE</code>，这两个环境变量可以用来设置PHP配置项。</p><p>其中：</p><blockquote><p><code>PHP_VALUE</code>:用来设置模式为：<code>PHP_INI_USER</code>和<code>PHP_INI_ALL</code>的选项。</p></blockquote><blockquote><p><code>PHP_ADMIN_VALUE</code>:可以用来设置所有选项</p></blockquote><p>通过这个方式对环境变量进行传入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;, &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/index.php&#x27;, &#x27;SCRIPT_NAME&#x27;: &#x27;/index.php&#x27;, &#x27;QUERY_STRING&#x27;: &#x27;?a=1&amp;b=2&#x27;, &#x27;REQUEST_URI&#x27;: &#x27;/index.php?a=1&amp;b=2&#x27;, &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;, &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: &#x27;12345&#x27;, &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;, &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27; &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;, &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27;&#125;</span><br></pre></td></tr></table></figure><p>通过对传入的环境变量进行修改，可以将PHP-FPM中的环境变量进行设置。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220702173235441.png" alt="image-20220702173235441"></p><p>常见的方式就是直接使用<code>PHP_ADMIN_VALUE</code>进行设置，然后就能通过php:&#x2F;&#x2F;input伪协议来进行任意代码执行。同时也可以根据需要，开启相应的<strong>远程文件包含设置</strong>。</p><h6 id="PHP-FPM未授权访问漏洞："><a href="#PHP-FPM未授权访问漏洞：" class="headerlink" title="PHP-FPM未授权访问漏洞："></a>PHP-FPM未授权访问漏洞：</h6><p>因为可以通过<code>PHP_VALUE</code>和<code>PHP_ADMIN_VALUE</code>这两个环境变量对PHP配置进行设置，所以攻击者可以通过<code>PHP-FPM</code>执行任意代码，实现代码执行漏洞。</p><p>初次之外，因为PHP-FPM和Web服务器中间件是通过网络进行沟通的，所以会有越来越多的集群将PHP-FPM直接绑定在公网上，所有人都可以对起进行访问，也就是说，任何人都可以伪装成Web服务器中间件来让PHP-FPM执行我们想要执行的恶意代码。这就会造成PHP-FPM的未授权访问漏洞。</p><p>（简单来说，就是可以通过伪装成Web服务器的方式，来对PHP-FPM发送数据，以执行需要的代码，或者是访问需要的网页，前提是PHP-FPM这个组件在公网，可以直接进行访问）</p><h6 id="SSRF中对于FPM-x2F-FastCGI的攻击："><a href="#SSRF中对于FPM-x2F-FastCGI的攻击：" class="headerlink" title="SSRF中对于FPM&#x2F;FastCGI的攻击："></a>SSRF中对于FPM&#x2F;FastCGI的攻击：</h6><p>可以看见的是，因为上述攻击中，要求我们可以从公网访问到PHP-FPM，如果不是公网，而是内网访问的话，就不能直接发包。<strong>要进行攻击的话，就需要从内网进行攻击，例如使用SSRF来进行反打。</strong></p><p>只要可以调用相关的函数，就可以通过url进行payload的传输，然后就能进行攻击。</p><h6 id="这篇总结相当好"><a href="#这篇总结相当好" class="headerlink" title="这篇总结相当好"></a>这篇总结相当好</h6><blockquote><p><a href="https://copyfuture.com/blogs-details/20210624174402663W">https://copyfuture.com/blogs-details/20210624174402663W</a></p></blockquote><h4 id="Redis协议（RESP协议）："><a href="#Redis协议（RESP协议）：" class="headerlink" title="Redis协议（RESP协议）："></a>Redis协议（RESP协议）：</h4><blockquote><p>应用系统和Redis之间通过Redis协议（RESP）进行交互。</p><p><strong>请求响应模式</strong></p><p>Redis协议使用TCP，也就是客户端和Redis之间保持双工的连接。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220704205113835.png" alt="image-20220704205113835"></p><p>也就是说，Redis协议就是专门用于客户端和Redis之间交互的协议。那么什么是Redis呢？</p><p><strong>Redis：</strong></p><p>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是<strong>跨平台的非关系型数据库</strong>。</p><p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、<strong>可选持久性的键值对(Key-Value)存储数据库</strong>，并提供多种语言的 API。</p><p><strong>Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。</strong></p><p>Redis是完全开源的，遵守BSD协议，是一个高性能的key-value数据库，相较于其他的key-value缓存产品，主要有三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><p>Redis的优势：</p><ul><li>性能极高 – Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish&#x2F;subscribe, 通知, key 过期等等特性。</li></ul><p>Redis和其他的key-value存储有什么不同：</p><ul><li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li><li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li></ul></blockquote><p><strong>常见的漏洞使用方式：</strong></p><h5 id="Redis未授权访问："><a href="#Redis未授权访问：" class="headerlink" title="Redis未授权访问："></a>Redis未授权访问：</h5><blockquote><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip访问等，这样将会将 Redis服务暴露到公网上。</p><p>如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取Redis 的数据。 </p></blockquote><p>也就是当Redis直接被绑定在公网的时候，可以直接伪造请求，然后对<code>Redis</code>直接进行访问，执行相关的指令。</p><p><strong>漏洞危害：</strong></p><blockquote><p>（1）攻击者无需认证访问到内部数据，可能导致敏感信息泄露，也可以恶意执行flushall来清空所有数据<br>（2）攻击者可通过EVAL执行lua代码，或通过数据备份功能往磁盘写入后门文件<br>（3）如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器</p></blockquote><p><strong>Redis常见命令：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220705140318215.png" alt="image-20220705140318215"></p><p>那么相关的使用方式，就是当<code>Redis</code>没有被暴露在公网的情况下，使用<code>SSRF</code>从内网进行攻击反打。</p><h5 id="SSRF利用Redis协议方式："><a href="#SSRF利用Redis协议方式：" class="headerlink" title="SSRF利用Redis协议方式："></a>SSRF利用Redis协议方式：</h5><blockquote><p>redis客户端与服务端通信，使用RESP（REdis Serialization Protocal，redis序列化协议）协议通信，该协议是专门为redis设计的通信协议，但也可以用于其它客户端-服务器通信的场景。</p><p>RESP可以用于序列化不同的数据类型，如：整型、字符串、数组…并且为错误提供专门的类型；客户端发送请求时，以字符串数组的作为待执行命令的参数。redis服务器根据不同的命令返回不同的数据类型。 </p><p>RESP协议支持五种数据类型：<br>1、简单字符串（Simple Strings）<br>2、错误数据（Errors）<br>3、整数（Integers）<br>4、批量字符串（Bulk Strings）<br>5、数组（Arrays）</p><p>当客户端请求服务器的时候，会以批量数据类型的数组请求封装。当服务端发送响应给客户端的时候，根据命令实现的不同，返回响应的数据类型。</p><p>不同的数据类型是根据请求&#x2F;响应报文的第一个字节进行区分的：</p><ul><li>简单字符串以+开头</li><li>错误数据以-开头</li><li>整数以:开头</li><li>批量字符串以$开头</li><li>数组以*开头</li></ul><p>RESP协议发不同部分，使用<code>\r\n</code>（CRLF）进行分隔。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220705142938907.png" alt="image-20220705142938907"></p><p>类似上面的数据类型，因为是建立在TCP层，因此可以使用wireshark进行抓包分析。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220705143132813.png" alt="image-20220705143132813"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Web漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssrf </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
